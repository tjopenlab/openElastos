<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Kortide DCD API: crt_file.car文件参考</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>首页</span></a></li>
    <li><a href="globals.html"><span>全部</span></a></li>
    <li class="current"><a href="Engineglobals.html"><span>引擎部分</span></a></li>
    <li><a href="UIglobals.html"><span>UI部分</span></a></li>
  </ul>
</div>
<h1>CRT函数参考</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>函数</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#81a531c31fb53f81d3a32dbe5636d5ee">dcd_fopen</a> (<a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *filename, <a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">打开文件.  <a href="#81a531c31fb53f81d3a32dbe5636d5ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#d478acced63488eab830d794b09078d0">dcd_fclose</a> (FILE *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">关闭文件.  <a href="#d478acced63488eab830d794b09078d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#9f65bb0fa8cf199059ed2ac0620494a0">dcd_fwrite</a> (void *buffer, size_t size, size_t count, FILE *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将数据写入文件流.  <a href="#9f65bb0fa8cf199059ed2ac0620494a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#c98dbb63bb931662c950b9cf86bd0fe1">dcd_fread</a> (void *buffer, size_t size, size_t count, FILE *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将数据写入文件流.  <a href="#c98dbb63bb931662c950b9cf86bd0fe1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#857c4a81d5c284948618921360f798ed">dcd_access</a> (char *path, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">测定文件的访问权限.  <a href="#857c4a81d5c284948618921360f798ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#481a04959116cebbae989eb8c0104685">dcd_feof</a> (FILE *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">判断文件流是否具有文件尾（end-of-file）指示器.  <a href="#481a04959116cebbae989eb8c0104685"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#3108589670eb0571cc8470ebbe187952">dcd_fseek</a> (FILE *stream, long offset, int origin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将文件指针移动到指定位置.  <a href="#3108589670eb0571cc8470ebbe187952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#2a79a31798124a8db1dac3aac744db10">dcd_ftell</a> (FILE *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">获取文件指针的当前位置.  <a href="#2a79a31798124a8db1dac3aac744db10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#85e9624330baeb71b8d0ca0db6d5674d">dcd_remove</a> (<a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">删除文件.  <a href="#85e9624330baeb71b8d0ca0db6d5674d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#ad2a4e1b11ece315ace4acc7f3e529b5">dcd_rename</a> (<a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *oldname, <a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *newname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">重新命名文件或路径名.  <a href="#ad2a4e1b11ece315ace4acc7f3e529b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#66cc235e62d994073f859f5b87e3f9aa">dcd_memset</a> (void *dest, int c, size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将缓冲区设置成指定的字符.  <a href="#66cc235e62d994073f859f5b87e3f9aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#1b822fd4f5c98a4771782b6a8eb1fefc">dcd_memcmp</a> (void *buf1, void *buf2, size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">比较两个缓冲区的字符.  <a href="#1b822fd4f5c98a4771782b6a8eb1fefc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#a4e11406b298c77afacace15c115cff9">dcd_memcpy</a> (void *dest, void *src, size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">在两个缓冲区之间拷贝字符.  <a href="#a4e11406b298c77afacace15c115cff9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#53bc5a5967cb2a44c29c8ac24293849c">dcd_memmove</a> (void *dest, void *src, size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">把一个缓冲区里的内容移到另一个缓冲区.  <a href="#53bc5a5967cb2a44c29c8ac24293849c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#481f141470ca69b0658f6d8b815a8e2d">dcd_mkdir</a> (<a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *dirname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">创建一个新的目录.  <a href="#481f141470ca69b0658f6d8b815a8e2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">time_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#e83e1beb8be42c8193b1569285fb8f68">dcd_time</a> (time_t *sysTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">获得系统当前时间.  <a href="#e83e1beb8be42c8193b1569285fb8f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#2f16d30ee643180eed07e694e5e6eded">dcd_malloc</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">分配指定大小的内存块.  <a href="#2f16d30ee643180eed07e694e5e6eded"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#7227a9b9877c0dde8fab3c46066b77e7">dcd_realloc</a> (void *memblock, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">重新分配内存块.  <a href="#7227a9b9877c0dde8fab3c46066b77e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="crt__file_8car.html#07abf04ca88a4696da1e610d10e07238">dcd_free</a> (void *memblock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">释放已分配的内存块.  <a href="#07abf04ca88a4696da1e610d10e07238"></a><br></td></tr>
</table>
<hr><h2>函数文档</h2>
<a class="anchor" name="857c4a81d5c284948618921360f798ed"></a><!-- doxytag: member="crt_file.car::dcd_access" ref="857c4a81d5c284948618921360f798ed" args="(char *path, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_access           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
测定文件的访问权限.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>- 指向文件或者目录的路径的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- 设定的权限. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>如果文件的权限与给定的权限相符，则返回0，如果文件不存在或者与给定的权限不一致，则返回-1.此时，错误号被设置为如下的常量之一： <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD align=center><b>错误号</b></TD>
			<TD align=center><b>描述</b></TD>
		</THEAD>
		<TR>
			<TD>EACCES</TD>
			<TD>文件的共享模式不允许指定的操作</TD>
		</TR>
		<TR>
			<TD>ENOENT</TD>
			<TD>指定文件或路径不存在</TD>
		</TR>
	</table>
</BODY>
</HTML>
 </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>当输入为文件时，该函数用以确定指定的文件是否存在，并且该文件可以使用由mode指定的模式进行访问。当输入为目录时，此函数只能确定指定的目录是否存在. <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD align=center>模式参数值</TD>
			<TD align=center>检查文件属性</TD>
		</THEAD>
		<TR>
			<TD>00</TD>
			<TD>文件存在</TD>
		</TR>
		<TR>
			<TD>02</TD>
			<TD>写权限</TD>
		</TR>
		<TR>
			<TD>04</TD>
			<TD>读权限</TD>
		</TR>
		<TR>
			<TD>06</TD>
			<TD>读写权限</TD>
		</TR>
	</table>
</BODY>
</HTML>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="d478acced63488eab830d794b09078d0"></a><!-- doxytag: member="crt_file.car::dcd_fclose" ref="d478acced63488eab830d794b09078d0" args="(FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_fclose           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
关闭文件.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件名的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>如果成功关闭文件，返回0；否则，返回EOF.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_fclose关闭文件.所有与此流相关的缓冲区都事先清空以便关闭.在文件流关闭时，系统分配的缓冲区被释放. </dd></dl>

</div>
</div><p>
<a class="anchor" name="481a04959116cebbae989eb8c0104685"></a><!-- doxytag: member="crt_file.car::dcd_feof" ref="481a04959116cebbae989eb8c0104685" args="(FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_feof           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
判断文件流是否具有文件尾（end-of-file）指示器.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件结构的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>当前一次读操作试图读取超过文件尾时会设置文件尾（end-of-file）指示器，dcd_feof返回非0值。如果文件流不具有文件尾（end-of-file）指示器，dcd_feof返回0。此函数没有错误返回值.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>dcd_feof(可以被当作函数或是宏)用来判断文件流是否具有文件尾(end-of-file)指示器.当到达文件流的结尾时，读操作会为文件流设置文件尾(end-of-file)指示器，直到文件流被关闭，或dcd_fseek等函数作用于该文件流。 </dd></dl>

</div>
</div><p>
<a class="anchor" name="81a531c31fb53f81d3a32dbe5636d5ee"></a><!-- doxytag: member="crt_file.car::dcd_fopen" ref="81a531c31fb53f81d3a32dbe5636d5ee" args="(DcdChar *filename, DcdChar *mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* dcd_fopen           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
打开文件.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>- 指向文件名的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- 指向文件打开模式的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>返回文件流指针，指向被打开的文件，如果出错，返回空指针. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>参数mode指定了的文件打开方式，具体内容如下: <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>参数mode的值</TD>
			<TD>对应的文件打开方式</TD>
		</THEAD>
		<TR>
			<TD> "w" </TD>
			<TD>以只写方式打开空文件。如果给定的文件存在，内容将被清空。</TD>
		</TR>
		<TR>
			<TD> "r" </TD>
			<TD>以只读方式打开文件。如果文件不存在或者没有找到，函数调用失败。</TD>
		</TR>
		<TR>
			<TD> "a" </TD>
			<TD>以追加方式打开文件，在写入数据前不删除EOF标志。如果文件不存在，则首先创建文件。</TD>
		</TR>
		<TR>
			<TD> "w+" </TD>
			<TD>以读/写方式打开一个空文件。如果给定的文件存在，内容将被清空。</TD>
		</TR>
		<TR>
			<TD> "r+" </TD>
			<TD>以读/写方式打开文件(此文件必须存在）。</TD>
		</TR>
<TR><TD> "a+" </TD>
<TD>以读/追加方式打开文件；追加操作包括：向文件写入新数据之前删除EOF标志，完成写入后重建EOF标志；如果文件不存在，则首先创建文件。</TD>
</TR>
</table></p>
<p>除了上述参数以外，mode中可以包含如下字符，来指定换行符的转换方式。</p>
<table border=1>
<THEAD><TD>参数mode中包含的字符</TD>
<TD>对应的换行符的转换方式</TD>
</THEAD>
<TR><TD> t </TD>
<TD>以文本(转换后)方式打开文件。在这种模式下，CTRL+Z被认为是文件的结束标志。以"a+"方式打开文件读/写时，_fdopen在文件末尾检测并删除CTRL+Z。这样做是因为，在以CTRL+Z结束的文件中，调用fseek和ftell移动文件指针时，在文件末尾附近fseek可能会发生错误。并且, 在文本模式下，输入时的回车和换行符转换为单个换行符；输出时，换行符转换为回车和换行两个字符。</TD>
</TR>
<TR><TD>b</TD>
<TD>以二进制方式(未转换)打开文件，不进行包括回车和换行符在内的转换。</TD>
</TR>
<TR><TD>c</TD>
<TD>设置相关的filename的确认位有效，以便调用fflush时，文件缓冲区的内容可以直接写入磁盘。</TD>
</TR>
<TR><TD>n</TD>
<TD>重新设置相关的filename的确认位无效。这是缺省设置。</TD>
</TR>
</table>
<p>模式选项c，n，t是dcd_fopen的扩展，当需要兼容ANSI时，不应该使用它们。</p>
<p>如果t或b作为参数的前缀，函数调用失败，返回NULL。</p>
</BODY>
</HTML>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c98dbb63bb931662c950b9cf86bd0fe1"></a><!-- doxytag: member="crt_file.car::dcd_fread" ref="c98dbb63bb931662c950b9cf86bd0fe1" args="(void *buffer, size_t size, size_t count, FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dcd_fread           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将数据写入文件流.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>- 存放数据的缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- 元素大小(字节数). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 要读出的最大元素个数. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件结构的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>函数dcd_fread返回实际读出的完整元素的个数.出错或者未达到count就遇到文件结束符时，返回值可能小于参数count.如果size或count为0，dcd_fread返回0，buffer内容不变.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_fread从输入文件流中读取count个完整元素，并存储在buffer中，元素大小为size个字节.与文件流相关联的文件指针按实际读出的字节数递增.如果发生错误，文件指针的位置是不确定的.没有完整读出的元素，值也是不确定的. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07abf04ca88a4696da1e610d10e07238"></a><!-- doxytag: member="crt_file.car::dcd_free" ref="07abf04ca88a4696da1e610d10e07238" args="(void *memblock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dcd_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>memblock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
释放已分配的内存块.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memblock</em>&nbsp;</td><td>- 指向已分配的并准备释放的内存块的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>此函数无返回值. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_free释放由函数dcd_malloc、dcd_realloc分配的内存块。释放的字节数等于申请时分配到的字节数（若调用dcd_realloc，则是重新分配的字节数）。如果memblock为NULL，忽略此指针，函数dcd_free立即返回。试图释放无效指针(指向不是由dcd_malloc、dcd_realloc函数所分配的内存块的指针),可能影响以后的分配请求，并引起错误. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3108589670eb0571cc8470ebbe187952"></a><!-- doxytag: member="crt_file.car::dcd_fseek" ref="3108589670eb0571cc8470ebbe187952" args="(FILE *stream, long offset, int origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_fseek           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将文件指针移动到指定位置.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件结构的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>- 相对origin的偏移字节数. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>- 初始位置. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>如果成功，返回0。否则，返回非零值。如果设备无法查找，没有定义此类情况的返回值. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_fseek将文件指针移动到新位置，新位置相对初始位置的偏移量是offset个字节，下一次操作在新位置进行.在被打开的文件流中，下一次操作既可以是读，也可以是写.参数origin必须是如下常量（定义在stdio.h里）中的一个： <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>参数origin的值</TD>
			<TD>描述</TD>
		</THEAD>
<TR><TD>SEEK_CUR</TD>
<TD>文件指针的当前位置</TD>
</TR>
<TR><TD>SEEK_END</TD>
<TD>文件尾</TD>
</TR>
<TR><TD>SEEK_SET</TD>
<TD>文件头</TD>
</TR>
</table>
</BODY>
</HTML>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a79a31798124a8db1dac3aac744db10"></a><!-- doxytag: member="crt_file.car::dcd_ftell" ref="2a79a31798124a8db1dac3aac744db10" args="(FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long dcd_ftell           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
获取文件指针的当前位置.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件结构的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>返回文件指针的当前位置。对于以文本模式打开的文件流，因为进行了回车换行转换，返回值不能反映出文件指针的物理偏移量。出错时，返回-1L.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_ftell获取文件指针的当前位置.此位置为，文件指针的当前位置相对于文件头的偏移量. </dd></dl>
<dl class="attention" compact><dt><b>注意:</b></dt><dd>当打开文件准备追加数据时，文件指针的当前位置由最后一次I/O操作决定，而不是由将要写入的位置决定.例如，为了追加数据而打开文件，且最后一次操作是读，文件指针应该在下一次开始读的位置，而不是下一次开始写的位置.(当打开文件准备追加数据时，在写之前，文件指针将被移动到文件末尾)如果在此文件上，还没有做过任何I/O操作，文件指针指向文件头. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f65bb0fa8cf199059ed2ac0620494a0"></a><!-- doxytag: member="crt_file.car::dcd_fwrite" ref="9f65bb0fa8cf199059ed2ac0620494a0" args="(void *buffer, size_t size, size_t count, FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dcd_fwrite           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将数据写入文件流.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>- 指向要写入数据的缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- 元素大小(字节数). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 要写入的最大元素个数. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- 指向文件结构的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>函数dcd_fwrite返回实际写入文件流的完整元素的个数。如果发生错误，其值可能小于count，并且文件位置指针无法确定.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_fwrite将count个元素写入输出文件流，每个元素大小为size个字节.与文件流相关联的文件指针按实际写入的字节数递增.如果文件流以文本模式打开，每个回车会替换为回车加换行符.替换对返回值没有影响. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f16d30ee643180eed07e694e5e6eded"></a><!-- doxytag: member="crt_file.car::dcd_malloc" ref="2f16d30ee643180eed07e694e5e6eded" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dcd_malloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
分配指定大小的内存块.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- 需要分配的内存块的大小（单位：字节）。如果为零，则dcd_malloc分配一个大小为零的内存块，并且返回一个正确的指针指向它。size不能超过c_uMaxAllocationSize常量所指定的最大分配字节数。可以规定c_uMaxAllocationSize的最小实现值为4092. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd><HTML>
<BODY>
<table border=1>
<THEAD><TD>返回值</TD>
<TD>描述</TD>
</THEAD>
<TR><TD>NULL</TD>
<TD>分配失败，没有足够的内存</TD>
</TR>
<TR><TD>非NULL值</TD>
<TD>分配成功，返回所分配的内存块的首地址</TD>
</TR>
</table></BODY>
</HTML>
 </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>此函数用于分配指定大小的内存块.实际分配的内存块可能会大于指定的大小，因为可能需要额外的空间来存放维护信息. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b822fd4f5c98a4771782b6a8eb1fefc"></a><!-- doxytag: member="crt_file.car::dcd_memcmp" ref="1b822fd4f5c98a4771782b6a8eb1fefc" args="(void *buf1, void *buf2, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_memcmp           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
比较两个缓冲区的字符.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>- 指向第一个缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>- 指向第二个缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 要比较的字符数. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>返回值反映两个缓冲区之间的关系：. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_memset把缓冲区的前count个字符设置成由C指定的字符 <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>返回值</TD>
			<TD>buf1 和 buf2 之间的第一个不同字节的关系</TD>
		</THEAD>
		<TR><TD>&lt;0</TD>
<TD>buf1 小于 buf2</TD>
</TR>
<TR><TD>0</TD>
<TD>buf1 等于 buf2</TD>
</TR>
<TR><TD>&gt;0</TD>
<TD>buf1 大于 buf2</TD>
</TR>
</table></BODY>
</HTML>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4e11406b298c77afacace15c115cff9"></a><!-- doxytag: member="crt_file.car::dcd_memcpy" ref="a4e11406b298c77afacace15c115cff9" args="(void *dest, void *src, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dcd_memcpy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
在两个缓冲区之间拷贝字符.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- 指向目的缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- 指向源缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 要拷贝的字符数. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>dcd_memcpy返回指向目的缓冲区的指针. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_memcpy将源缓冲区中count个字节的内容拷贝到目标缓冲区.如果源缓冲区和目标缓冲区有重叠，此函数不能保证，在覆盖之前将原始数据从重叠区域里拷贝出来.可以使用函数dcd_memmove处理重叠区域. </dd></dl>

</div>
</div><p>
<a class="anchor" name="53bc5a5967cb2a44c29c8ac24293849c"></a><!-- doxytag: member="crt_file.car::dcd_memmove" ref="53bc5a5967cb2a44c29c8ac24293849c" args="(void *dest, void *src, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dcd_memmove           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
把一个缓冲区里的内容移到另一个缓冲区.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- 指向目的缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- 指向源缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 要拷贝的字符所占的字节数. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>返回指向目的缓冲区的指针. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_memmove将count个字节从源缓冲区拷贝到目标缓冲区，如果源缓冲区和目标缓冲区有重叠，此函数确保，在覆盖之前将原始数据从重叠区域里拷贝出来. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66cc235e62d994073f859f5b87e3f9aa"></a><!-- doxytag: member="crt_file.car::dcd_memset" ref="66cc235e62d994073f859f5b87e3f9aa" args="(void *dest, int c, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dcd_memset           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将缓冲区设置成指定的字符.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- 指向目的缓冲区的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>- 要设置的字符. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- 字符的数目. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>返回指针dest. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_memset把缓冲区的前count个字符设置成由C指定的字符 </dd></dl>

</div>
</div><p>
<a class="anchor" name="481f141470ca69b0658f6d8b815a8e2d"></a><!-- doxytag: member="crt_file.car::dcd_mkdir" ref="481f141470ca69b0658f6d8b815a8e2d" args="(DcdChar *dirname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_mkdir           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>dirname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
创建一个新的目录.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dirname</em>&nbsp;</td><td>- 指向要创建目录路径的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>如果新的目录建立成功，函数返回0，如果函数在执行过程中出现错误，函数返回-1，并将错误号置为下列值： <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>错误号</TD>
			<TD>描述</TD>
		</THEAD>
<TR><TD>EEXIST</TD>
<TD>因为dirname与已经存在的文件名、目录名以及设备名相同，目录没有创建</TD>
</TR>
<TR><TD>ENOENT</TD>
<TD>路径没有找到</TD>
</TR>
</table></BODY>
</HTML>
 </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>dcd_mkdir函数根据dirname创建新目录，dcd_mkdir函数每次调用只能创建一个新目录.因此只有dirname的最后一部分才是新目录名.dcd_mkdir不解释路径分隔符. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7227a9b9877c0dde8fab3c46066b77e7"></a><!-- doxytag: member="crt_file.car::dcd_realloc" ref="7227a9b9877c0dde8fab3c46066b77e7" args="(void *memblock, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dcd_realloc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>memblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
重新分配内存块.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memblock</em>&nbsp;</td><td>- 指向以前分配内存块的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- 所需重新分配的字节数. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>dcd_realloc函数返回void型指针，该指针指向重新分配的空间(可能已经移动).如果参数size为0而且参数memblock不为NULL，或者内存不足以扩充到指定大小，返回NULL.在第一种情况下，已分配的内存块被释放.在第二种情况下，已分配的内存块不变.返回值指向的存储空间会被恰当地分配，以保证存储任一类型的对象.为了返回void类型以外的指针，要对返回值进行类型转换. </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_realloc改变已分配的内存块的大小。参数memblock指向已分配的内存块的起始位置.如果memblock为NULL，dcd_realloc函数执行与dcd_malloc函数相同的操作，分配一个size大小的新内存块。如果memblock不为NULL，它应该是前面调用函数dcd_calloc、dcd_malloc或者dcd_realloc所返回的指针.参数size为重新分配的字节数.尽管新分配的内存块可能不在原来的位置，但其容量不会变为新块与原块中容量较小的那个，即其容量大于或等于原块容量.新的内存块可能分配在新的内存区，因此函数realloc返回的指针，不一定是通过参数memblock传递的指针(指向原内存块). </dd></dl>

</div>
</div><p>
<a class="anchor" name="85e9624330baeb71b8d0ca0db6d5674d"></a><!-- doxytag: member="crt_file.car::dcd_remove" ref="85e9624330baeb71b8d0ca0db6d5674d" args="(DcdChar *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
删除文件.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>- 指向要删除的文件名的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>如果删除成功，返回0；否则，返回-1。当文件为只读、文件或路径找不到、给定参数filename为目录名或者文件正在使用时，此函数运行失败.</dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>函数dcd_remove删除path指定的文件,在删除文件前，所有当前文件的句柄必须关闭. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad2a4e1b11ece315ace4acc7f3e529b5"></a><!-- doxytag: member="crt_file.car::dcd_rename" ref="ad2a4e1b11ece315ace4acc7f3e529b5" args="(DcdChar *oldname, DcdChar *newname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dcd_rename           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcdenum_8car.html#a55c825970107ffb49428d8d1cf480b3">DcdChar</a> *&nbsp;</td>
          <td class="paramname"> <em>newname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
重新命名文件或路径名.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldname</em>&nbsp;</td><td>- 指向旧文件或路径名的指针. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newname</em>&nbsp;</td><td>- 指向新文件或路径名的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>成功返回0，出错则返回非0值，并将errno设为如下值： <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>errno值</TD>
			<TD>描述</TD>
		</THEAD>
<TR><TD>EACCES</TD>
<TD>新名字代表的文件或路径已经存在，或者是因为路径错误而不能创建，或者旧名字是个路径，而新名字在不同的子目录下。</TD>
</TR>
<TR><TD> ENOENT</TD>
<TD>旧的文件或者路径名不存在。</TD>
</TR>
<TR><TD>EINVAL</TD>
<TD>名字中含有非法字符。</TD>
</TR>
</table>
</BODY>
</HTML>

 </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>dcd_rename函数用新文件或路径名去替代旧文件或路径名.旧文件或路径名必须是一个存在的文件或路径.新文件或路径名必须是一个不存在的文件或路径.dcd_rename函数能移动文件到不同的目录或者设备中，但不能移动目录.目录只能被重命名，而不能移动. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e83e1beb8be42c8193b1569285fb8f68"></a><!-- doxytag: member="crt_file.car::dcd_time" ref="e83e1beb8be42c8193b1569285fb8f68" args="(time_t *sysTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t dcd_time           </td>
          <td>(</td>
          <td class="paramtype">time_t *&nbsp;</td>
          <td class="paramname"> <em>sysTime</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
获得系统当前时间.
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sysTime</em>&nbsp;</td><td>- 指向存储时间的指针. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>函数返回以秒为单位的系统时间值，无错误返回. <HTML>
<BODY>
	<table border=1>
		<THEAD>
			<TD>错误号</TD>
			<TD>描述</TD>
		</THEAD>
<TR><TD>EEXIST</TD>
<TD>因为dirname与已经存在的文件名、目录名以及设备名相同，目录没有创建</TD>
</TR>
<TR><TD>ENOENT</TD>
<TD>路径没有找到</TD>
</TR>
</table></BODY>
</HTML>
 </dd></dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>dcd_time函数获取的是UTC（Coordinated Universal Time，通用协调时间）时间，即从UTC时间1970年1月1日00:00:00开始到当前系统时间所经过的总秒数，返回值保存在timer指针所指的位置中.当不需要保存返回值时，参数可以为NULL. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>
<a href="http://www.kortide.com.cn">© Kortide Corp.All rights reserved.</a></small></address></body>
</html>
