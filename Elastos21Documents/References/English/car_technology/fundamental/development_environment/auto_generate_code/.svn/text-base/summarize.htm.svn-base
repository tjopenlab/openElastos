<!--==========================================================================-->
<!-- Copyright (c) 2000-2004,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>Automatic Code Framework Generation</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>
<h2>Advantages Of Automatic Code Framework Generation</h2>
    <p>The main purpose of compile environment automatic code generation is to encapsulate and abstract component coding and use. We want to let user develop and use CAR component more easily.</p>
    <p>The following sections shows how easy is the use of CAR component technology: </p>
    <ol>
        <li>CAR is used to write CAR component interface description file. Interface of Hello component is easy, but if user implement it in C++, many technical details needs to be considered. Write hello.car using the CAR language, not only simple but also let the user be used to component programming method, not entangled with the internal technical details. 
        <li>Automatically generates metadata. CLS file is the compressed template library of CAR file, which describes interface, class, method, struct, enumeration definitions of the whole component. With cls file, one can obtain interface, function invocation method of this component and can even generate source code framework. When linking and generating hello.dll, put hello.cls in hello.dll, which is equivalent to connecting a manual with the component. Therefore no matter where the component is copied or moved to,one always can use a component accurately.
        <li>Smart pointer implementation greatly simplifies the difficulty of user component invocation. The most difficult problem user faces while invoking component is the interface reference count rules. It is not easy to know when to AddRef and when to Release. But with smart pointer, user who invokes component interface feels like using a normal C++ object. This greatly make user development convenient.
        <li>Important parts of many component, such as class factory, registered function in DLL etc are generated by the compile environment automatically. User manual implementation is no longer needed.
    </ol>
    <p>Of course to most users, these details of compilation can be ignored. Component programming can be achieved by just filling in implementation code in source code framework generated under CAR compile environment. But for users who are interested in component technology, these knowledge may be helpful to programming.</p>
    <p><font color="red"><b>Note:</b>Middleware marshalling consists of build&nbsp;in and dynamic proxy two methods. During compilation of Elastos2.0 CAR component, some code is generated by the compile environment, including source code framework and component interface abstraction.But these codes are not used for marshalling and no proxy or stub is generated.</font></p>

<body><script>footer("english")</script>
</body>
</html>