<!--==========================================================================-->
<!-- Copyright (c) 2000-2004,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>Automatic Code Framework Generation</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>

<body>
<h2>Internal Process Of Component Compilation</h2>
    <h3>Compiling component: </h3>
    <p>After filling in implementation code, use emake tool to compile the source code, then CAR component can be generated in the mirror directory. Different from generating source program framework, this emake command does not need to have parameter. After executing the emake command, we generate this component (hello.dll file) under the mirror directory.</p>
    <h3>Internal process: </h3>
    <p>This time the emake command does not have any parameter, the command is executed according to rules in the Elastos.SDK\build\misc\makefile.gnu script. Use emake&nbsp;-v you can see the whole compilation process.</p>
    <p>First generate compressed hello.cls resource library again using carc tool.</p>
    <pre class="code">
    carc  -a -c hello.cls hello.car
</pre>
    <p>Then use regezcom tool to register hello.cls in the system.</p>
    <pre class="code">
regezcom -c hello.cls -a \category.cfg \ -d бн\driver.cfg
</pre>
    <p>At last use mkimport tool to generate header file hello.h according to information in hello.cls .</p>
    <pre class="code">
mkimport  -p D:\бн\server -"|" hello.cls
</pre>
    <p>hello.h includes interface C++ definition and smart pointer implementation code. Other C++ header files and source files are generated by cls2src .</p>
    <pre class="code">
cls2src  -p D:\бн\server -b hello.cls
</pre>
    <p>This command generate multiple files including: </br>
        <ul>
            <li>_CHello.cpp: Implements AddRef/Release and QueryInterface of hello component.
            <li>_hellopub.cpp: Implements class factory creation and obtaining metadata DLL exit point function _EzComDllGetClassObject .
            <li>_CHello.h: Inheritance of _CHello class to interface IHello .
            <li>_Hello_1_0.h: Includes header file hello.h .
            <li>hello.etl: Binary file.
            <li>HelloClsInfo.cpp: Defines array g_Hello_classInfo, in which stores metadata for marshaling/unmarshaling. 
        </ul>
    </p>
    <p>The following create hello.def file, in which hello.dll exit point function is defined. Here is the following functions: </br>
    <b>
    DllGetClassObject = _EzComDllGetClassObject@12</br>
    DllCanUnloadNow = _EzComDllCanUnloadNow@0</br>
    DllRegisterServer = _EzComDllRegisterServer@0</br>
    DllUnregisterServer = _EzComDllUnregisterServer@0
    </b>
    </p>
    <p>Now you can use dlltool tool to generate interface library file hello.lib of hello.dll .</p>
    <pre class="code">
dlltool -C -d hello.def -e hello.exp -D hello.dll -l hello.lib
</pre>
    <p>hello.def and hello.lib are output files, hello.def is input file. hello.dll is only input as a file name, this file is not required now.</p>
    <p>hello.def file is a hello.dll exit point file, it is going to be needed when linking hello.dll .</br>hello.lib file is the entry point file of hello.dll, which is used when other program invokes hello.dll .</p>
    <p>Then resource script file hello.rc is generated. It contains two files: </p>
    <pre class="code">
1 ClassInfo hello.cls
1 ZTLB hello.etl
</pre>
    <p>Take hello.rc as input, hello.rsc resource file is generated using windres tool.</p>
    <pre class="code">
windres бн -o hello.rsc -i hello.rc
</pre>
    <p>Then CHello.cpp file is compiled using gcc to generate target file CHello.o .</p>
    <pre class="code">
gcc  бн   -o CHello.o бн\CHello.cpp
</pre>
    <p>Now linker ld can be used to generate hello.dll .</p>
    <pre class="code">
ld  бн -Map hello.map бн -o hello.dll  --start-group hello.rsc CHello.o -lelastos
-lelacrt hello.exp --end-group
</pre>
    <p>During the process of ld generating hello.dll, hello.map is also generated. This file records link information in hello.dll .</p>
    <p>Finally gcc generates depend.mk file, which records the dependency of CHello.cpp file to other program.</p>

<script>footer("english")</script>
</body>
</html>