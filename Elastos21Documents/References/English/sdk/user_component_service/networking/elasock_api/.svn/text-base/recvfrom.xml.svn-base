<!--==========================================================================-->
<!-- Copyright (c) 2000-2004,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<?xml version = "1.0" encoding="GB2312" ?>
<?xml:stylesheet type="text/xsl" href="/xsl/xsl_e/apimanual.xsl"?>

<manpage>
    <sample url="elasock\UDP"></sample>
    <volume>elasock API </volume>
    <title>recvfrom</title>
    <routine_idx> elasock_idx.htm </routine_idx>

    <description>
        <para>接收一个数据报并保存源地址。</para>
    </description>

    <syntax>
        <return_val>int</return_val>
        <parameters>
            <api_param>
                <param_type>SOCKET</param_type>
                <param_name>s</param_name>
                <param_note>
                    <para>已绑定的套接口。</para>
                </param_note>
            </api_param>
            <api_param>
                <param_type>char *</param_type>
                <param_name>buf</param_name>
                <param_note>
                    <para>接收数据缓冲区。</para>
                </param_note>
            </api_param>
            <api_param>
                <param_type>int</param_type>
                <param_name>len</param_name>
                <param_note>
                    <para>缓冲区长度。</para>
                </param_note>
            </api_param>
            <api_param>
                <param_type>int</param_type>
                <param_name>flags</param_name>
                <param_note>
                    <para>调用方式标志位，普通方式为0。</para>
                </param_note>
            </api_param>
            <api_param>
                <param_type>struct sockaddr *</param_type>
                <param_name>from</param_name>
                <param_note>
                    <para>（可选）指针，指向装有源地址的缓冲区</para>
                </param_note>
            </api_param>
            <api_param>
                <param_type>int *</param_type>
                <param_name>fromlen</param_name>
                <param_note>
                    <para>（可选）指针，指向from缓冲区的长度值</para>
                </param_note>
            </api_param>
        </parameters>
    </syntax>

    <return>
        <para>若无错误发生，recvfrom()返回读入的字节数。如果连接已终止将返回0。否则的话，返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError()获取相应错误代码。</para>
    </return>

    <remarks>
        <para>本函数从已连接或未连接套接口上接收数据，并可以记录数据发送源的地址。在此之前套接口的本地地址必须是确定的，对于服务器端，可以显式调用bind()或者隐式调用accept()。对于客户端，不鼓励显式调用bind()，客户端程序可以通过sendto()来隐式地建立套接口与本地地址的绑定。</para>
        <para>对SOCK_STREAM类型的套接口来说，本函数将返回所有的有效数据，最大可达缓冲区的大小，并忽略from和fromlen参数。</para>
        <para>对于数据报套接口，队列中第一个数据报中的数据被解包，但其大小不能超过缓冲区容量。如果数据报长度大于缓冲区容量，缓冲区中将只有数据报的前面部分，recv()返回已读入缓冲区的字节数，多余部分的数据将被丢弃。</para>
        <para>对于数据报套接口，若from参数为非空，数据发送源的地址将被复制到相应的SOCKADDR结构中。fromlen所指向的值初始化时为SOCKADDR结构的大小，当调用返回时该值为SOCKADDR结构中地址的实际大小。</para>
        <para>如果没有数据可读，在阻塞模式下，调用recvfrom()将阻塞套接口并等待数据到来；非阻塞套模式下将将返回SOCKET_ERROR错误。使用select()可以获知何时数据到达。</para>
        <para>所有经过传输缓冲并接收的数据将被复制到用户给出的缓冲区。如果阻塞套接口无接收数据，程序将阻塞直到数据到达。对于字节流套接口，一次recv()将读取所有已经到来的数据，并尽可能地充满用户给出的缓冲区；当阻塞发生时，如果接收到大于或等于一个字节的数据，或者收到另一端正常关闭连接的信号，阻塞过程都将结束。而对于数据报套接口，每一次recv()调用只处理远端一次send()传送过来的数据；且需要接收到完整的数据报才可以结束阻塞状态，但是允许数据报长度为0。</para>
        <para>如果字节流套接口的连接对方成功地中止了连接，并且本地已经接收完了所有数据，调用recvfrom()将立即返回已读取0字节。假如连接被强制中止，recvfrom()将返回WSAECONNRESET错误。</para>
        <para>标志位flags用于设置recv/recvfrom的接收方式，一般情况使用0。elasock中recv/recvfrom支持MSG_OOB和MSG_PEEK。</para>
        <para>MSG_PEEK</para>
        <para>当recv/recvfrom以该方式执行时，数据被放入用户缓冲区，但不从系统缓冲区内清除，好像是用户在“偷看”数据一样。在下一次以正常方式执行的recv/recvfrom取走数据之前，用户可以一直“偷”看当前数据。</para>
        <para>MSG_OOB </para>
        <para>当标志位为MSG_OOB时，recv/recvfrom将试图读取一个带外数据。在此之前，用户需要保证带外数据已经到来，否则将产生WSAEINVAL错误。比较合适的解决办法是，如果用户希望接收带外数据，可以在recv/recvfrom之前使用select并判断是否满足异常（带外）条件，如果条件满足，说明带外数据已经到来，这时就可以使用recv/recvfrom(....,MSG_OOB...)接收带外数据。</para>
        <para>带外数据在各种不同的socket中常常有不同的实现和语义，我们并不鼓励使用带外数据功能。</para>
    </remarks>

    <requirements>
        <system>
            <system_name>
                Windows 2000或更高版本；《和欣 2.0》或更高版本
            </system_name>
        </system>
        <headerfile>
            <file_name> winsock.h</file_name>
        </headerfile>
        <library>
            <lib_name> elasock.lib  </lib_name>
        </library>
    </requirements>

    <references>
        <reference>
            <ref_name>bind</ref_name>
            <ref_url>bind</ref_url>
        </reference>
        <reference>
            <ref_name>recv</ref_name>
            <ref_url>recv</ref_url>
        </reference>
        <reference>
            <ref_name>send</ref_name>
            <ref_url>send</ref_url>
        </reference>
        <reference>
            <ref_name>select</ref_name>
            <ref_url>select</ref_url>
        </reference>
        <reference>
            <ref_name>shutdown</ref_name>
            <ref_url>shutdown</ref_url>
        </reference>
        <reference>
            <ref_name>socket</ref_name>
            <ref_url>socket</ref_url>
        </reference>
        <reference>
            <ref_name>WSAStartup</ref_name>
            <ref_url>WSAStartup</ref_url>
        </reference>
    </references>
    <example>
    </example>
</manpage>
