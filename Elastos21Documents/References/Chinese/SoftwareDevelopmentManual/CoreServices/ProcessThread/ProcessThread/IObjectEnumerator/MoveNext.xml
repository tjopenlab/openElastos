<?xml version = "1.0" encoding="GB2312" ?>
    <?xml:stylesheet type="text/xsl" href="/xsl/xsl_c/methodmanual.xsl"?><manpage>
<sample url="sdk\operating_system\system_com_interface\IObjectEnumerator">MoveNext</sample>
<volume>对象枚举器 </volume>
<interface>IObjectEnumerator</interface><method>MoveNext</method>
    <description>
        <para>
   将枚举器的当前指针指向下一个对象。
        </para>
    </description>
    <syntax>
        <return_val> ECode </return_val>
         <parameters>
            <api_param>
                <param_inout>[out]</param_inout>
                <param_type> Boolean  *  </param_type>
                <param_name> pSucceeded </param_name>
                <param_note>
                    <para>
						 指向Boolean型的指针，用于获取判断结果，不能为空。若为TRUE，表示枚举器所指下一个对象存在；若为FLASE，则表示枚举器当前指针指向最后一个对象
                    </para>
                </param_note>
            </api_param>
        </parameters>
    </syntax>

	<return>
	<table>
	    <th>
		<td>返回值 </td>
		<td>描述</td>
	    </th>
	    <tr>
		<td>NOERROR</td>
		<td>方法调用成功</td>
	    </tr>
	    <tr>
		<td>E_INVALID_ARGUMENT</td>
		<td>参数错误</td>
	    </tr>
	    <tr>
		<td>E_INVALID_OPERATION</td>
		<td>非法操作</td>
	    </tr>
	</table>
	<para>参见<link url="../../../../../car_technology/fundamental/development_environment/car/ECode.htm">ECode</link>相关帮助。</para>
    </return>

	<remarks>
	    <para> 在创建一个对象枚举器或者调用<link url="Reset.htm">IObjectEnumerator::Reset</link>方法后，都会使对象枚举器指向对象集合的第一个对象之前。此时调用<link url="Current.htm">IObjectEnumerator::Current</link>方法会返回错误信息。所以如果要获取任意一个对象的接口指针必须通过调用<link url="MoveNext.htm">IObjectEnumerator::MoveNext</link>方法将对象枚举器后移并指向相应的对象，再调用<link url="Current.htm">IObjectEnumerator::Current</link>方法。</para>
		<para>如果对象枚举器当前指向进程对象集合的最后一个对象，调用<link url="MoveNext.htm">IObjectEnumerator::MoveNext</link>NOERROR，同时pSucceeded的内容为FALSE。</para>
	    <para>枚举对象创建之后，枚举对象集合中的对象发生了增减变化（例如线程运行退出了），如果没有进行<link url="Reset.htm">Reset</link>操作而进行MoveNext和<link url="Current.htm">Current</link>操作都会返回E_INVALID_OPERATION。如果创建枚举对象，不执行MoveNext就进行<link url="Current.htm">Current</link>操作会返回E_INVALID_OPERATION。</para>
	</remarks>

    <requirements>
        <system>
            <system_name>
				Windows 2000 或更高版本；Elastos操作系统
			</system_name>
        </system>
    </requirements>
    <example>
<pre>
//==========================================================================
//
// Description : The following example demonstrates the using of the
//               IObjectEnumerator.
//
//==========================================================================

#include &lt;elastos.h&gt;
#include &lt;stdio.h&gt;
using namespace Elastos;

int main()
{
    IProcess *iProc;

    // Gets the current process
    iProc = CProcess::GetCurrent();

    // Gets the module enumerator
    ECode ec;
    IObjectEnumerator   *iMods;
    ec = iProc-&gt;GetAllModules ((IObjectEnumerator **)&amp;iMods);
    if (FAILED(ec)) {
        printf(&quot;Get module enumerator failed, ec = 0x%08x.\n&quot;, ec);
        iProc-&gt;Release();
        return -1;
    }

    iProc-&gt;Release();

    // Resets the enumerator to the initial state
    ec = iMods-&gt;Reset();
    if (FAILED(ec)) {
        printf(&quot;Process enumerator Reset failed, ec = 0x%08x.\n&quot;, ec);
        iMods-&gt;Release();
        return -1;
    }

    printf(&quot;All modules in the process:\n&quot;);
    // enum the moudle
    // Advances the pointer of object enumerator to the next object
    Boolean bSucceeded;
    ec = iMods-&gt;MoveNext(&amp;bSucceeded);
    while (SUCCEEDED(ec) &amp;&amp; bSucceeded) {
        IModule  *iMod;
        // Gets the current object of the enumerator
        ec = iMods-&gt;Current((IInterface **)&amp;iMod);
        if (FAILED(ec)) {
            printf(&quot;Enumerate current module failed, ec = 0x%08x.\n&quot;, ec);
            iMods-&gt;Release();
            return -1;
        }

        WStringBuf_&lt;200&gt; ewsbName;
        //Gets the name of the module
        ec = iMod-&gt;GetName(&amp;ewsbName);
        if (FAILED(ec)) {
            printf(&quot;Get module name failed, ec = 0x%08x.\n&quot;, ec);

            iMods-&gt;Release();
            iMod-&gt;Release();
            return -1;
        }
        printf(&quot;    Module Name : %12S\n&quot;, (wchar_t*)ewsbName);

        iMod-&gt;Release();
        ec = iMods-&gt;MoveNext(&amp;bSucceeded);
    }

    iMods-&gt;Release();

    return 0;
}
</pre>
    </example>
<result>
All modules in the process:
    Module Name :     Test.exe
    Module Name :    ntdll.dll
    Module Name : kernel32.dll
    Module Name :  elastos.dll
    Module Name :   elaura.dll
    Module Name :  MSVCR80.dll
    Module Name :   msvcrt.dll
    Module Name :    ole32.dll
    Module Name :    GDI32.dll
    Module Name :   USER32.dll
    Module Name : ADVAPI32.dll
    Module Name :   RPCRT4.dll
    Module Name :    PSAPI.DLL
    Module Name : bootmods.dll
    Module Name :  environ.dll
    Module Name : ela_malloc.dll
    Module Name : ElCRuntime.dll
    Module Name : ElMathLib.dll
    Module Name :    IMM32.DLL
    Module Name :      LPK.DLL
    Module Name :    USP10.dll
</result>
</manpage>