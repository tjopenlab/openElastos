<?xml version="1.0" encoding="GB2312"?>
<?xml:stylesheet type="text/xsl" href="/xsl/xsl_c/manual.xsl"?>

<manpage>
    <sample url="sdk\operating_system\crt\libc\stdlib\_ecvt">_ecvt</sample>
    <title> _ecvt</title>
    <volume>C 运行库函数</volume>
    <routine_idx> slib_idx.htm </routine_idx>

    <description>
        <para>将双精度数转化成字符串。</para>
    </description>

    <syntax>
        <return_val>char *</return_val>
        <func_name>_ecvt</func_name>
        <parameters>
            <func_param>
                <param_type>double</param_type>
                <param_name>value</param_name>
                <param_note>
                    <para>要转换的双精度数</para>
                </param_note>
            </func_param>
            <func_param>
                <param_type>int</param_type>
                <param_name>count</param_name>
                <param_note>
                    <para>转换后保留的数字位数</para>
                </param_note>
            </func_param>
            <func_param>
                <param_type>int*</param_type>
                <param_name>dec</param_name>
                <param_note>
                    <para>小数点相对于字符串开始处的位置</para>
                </param_note>
            </func_param>
            <func_param>
                <param_type>int*</param_type>
                <param_name>sign</param_name>
                <param_note>
                    <para>双精度数的符号</para>
                </param_note>
            </func_param>
        </parameters>
    </syntax>

    <return>
        <para>_ecvt返回指向数字字符串的指针。无错误返回值。</para>
    </return>

    <remarks>
	    <para>函数_ecvt将双精度数转化为字符串。参数value代表要转换的双精度数，该函数将参数value存储成count位的字符串，并在串尾添加空字符('\0')；如果参数value的位数大于count，则将多出的低位数四舍五入，如果参数value的位数小于count，则在末位数后补充'0'至count位。</para>
	    <para>在函数调用后，只有数字部分被存储为字符串。从参数dec和sign中可获得小数点的位置和参数value的符号。参数dec指向一个整数，该整数值给出小数点相对于字符串开始处的位置。0和负数表示小数点位置在第一个数字的左边。参数sign指向一整数，表示参数value的符号。sign为0则value为正，sign非0则value为负。</para>
	    <para>函数_ecvt和_fcvt在进行转换时，使用单一的静态分配的缓冲区。每次调用此类函数，都会破坏前一次调用的结果。</para>
    </remarks>

    <requirements>
        <routine>
            <routine_name>_ecvt</routine_name>
            <headerfile>stdlib.h</headerfile>
            <compatibility>Windows 2000, Elastos </compatibility>
        </routine>
    </requirements>

    <example>
<pre>
//==========================================================================
// Copyright (c) 2000-2004,  Elastos, Inc.  All Rights Reserved.
//==========================================================================

/* _ecvt.cpp: This program uses _ecvt to convert a
 * floating-point number to a character string.
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    int      decimal,    sign;
    char     *buffer;
    int      precision = 10;
    double  source = 3.1415926535;

    buffer = _ecvt(source, precision, &amp;decimal, &amp;sign);
    printf(&quot;source: %2.10f    buffer: &apos;%s&apos;  decimal: %d  sign: %d\n&quot;,
              source, buffer, decimal, sign);

    return 0;
}
</pre>
    </example>
<result>
source: 3.1415926535    buffer: &apos;3141592654&apos;  decimal: 1    sign: 0
</result>



    <references>
        <reference>
            <ref_name>_fcvt</ref_name>
            <ref_url>_fcvt</ref_url>
        </reference>
    </references>

</manpage>