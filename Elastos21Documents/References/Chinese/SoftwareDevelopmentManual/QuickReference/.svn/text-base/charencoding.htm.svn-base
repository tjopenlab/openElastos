<!--==========================================================================-->
<!-- Copyright (c) 2000-2008,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>

<head>
    <title>字符编码</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="/xsl/docstyles.js"></script>

</head>

<body>
<h2>字符编码</h2>
<h3>编码简介</h3>
<p>由于文字中存在着大量的重复字符，而计算机天生就是用来处理数字的,为了减少需要保存的信息量，可以使用一个数字编码来表示每一个字符，通过对每一个字符规定一个唯一的数字代号，然后，对应每一个代号，建立其相对应的图形，这样，在每一个文件中，只需要保存每一个字符的编码就相当于保存了文字，在需要显示出来的时候，先取得保存起来的编码，然后通过编码表，可以查到字符对应的图形，然后将这个图形显示出来，这样就可以看到文字了，这些用来规定每一个字符所使用的代码的表格，就称为编码表。编码就是对我们日常使用字符的一种数字编号。
<h3>常用的编码简介</h3>
<ul>
	<li><b>ASCII</b>
		<p>ASCII（AmericanStandardCodeforInformationInterchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC646。
		<p>ASCII共定义了128个字符，其中33个字符无法显示（这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符，控制字符的用途主要是用来操控已经处理过的文本，在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。
		<p>虽然标准ASCII码是7位编码，但由于计算机基本处理单位为字节（1byte=8bit），所以一般仍以一个字节来存放一个ASCII字符。每一个字节中多余出来的一位（最高位）在计算机内部通常保持为0（在数据传输时可用作奇偶校验位）。
			
<li><b>ISO8859-1</b>
<p>ISO8859-1，正式编号为ISO/IEC8859-1:1998，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC8859的第一个8位字符集。它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用附加符号的拉丁字母语言使用。
<p>此字符集支持部分于欧洲使用的语言，包括阿尔巴尼亚语、巴斯克语、布列塔尼语、加泰罗尼亚语、丹麦语、荷兰语、法罗语、弗里西语、加利西亚语、德语、格陵兰语、冰岛语、爱尔兰盖尔语、意大利语、拉丁语、卢森堡语、挪威语、葡萄牙语、里托罗曼斯语、苏格兰盖尔语、西班牙语及瑞典语。
<p>英语虽然没有重音字母，但仍会标明为ISO/IEC8859-1编码。除此之外，欧洲以外的部分语言，如南非荷兰语、斯瓦希里语、印尼语及马来语、菲律宾他加洛语等也可使用ISO/IEC8859-1编码。
<p>法语及芬兰语本来也使用ISO/IEC8859-1来表示。但因它没有法语使用的œ、Œ、Ÿ三个字母及芬兰语使用的Š、š、Ž、ž，故于1998年被ISO/IEC8859-15所取代。（ISO8859-15同时加入了欧元符号）。
<li><b>ANSI</b>
	<p>为使计算机支持更多语言，通常使用0x80~0xFF范围的2个字节来表示1个字符。不同的国家和地区制定了不同的标准，由此产生了GB2312,BIG5,JIS等各自的编码标准。这些使用2个字节来代表一个字符的各种汉字延伸编码方式，称为ANSI编码。在简体中文系统下，ANSI编码代表GB2312编码，在日文操作系统下，ANSI编码代表JIS编码。不同ANSI编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段ANSI编码的文本中。
	<p>在非英文的环境中，应该将“字节串”作为ANSI字符串，采用适当的编码来得到UNICODE字符串，有可能“多个字节”才能得到“一个字符”。
<li><b>BIG5</b>
	<p>BIG5又称大五码或五大码，共收录13,053个中文繁体字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。
	<p>Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。在Big5的分区中：
	<ul>
<p>◆0x8140-0xA0FE：保留给使用者自定义字符（造字区）
<p>◆0xA140-0xA3BF：标点符号、希腊字母及特殊符号，包括在0xA259-0xA261，安放了双音节度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。
<p>◆0xA3C0-0xA3FE：保留。此区没有开放作造字区用。
<p>◆0xA440-0xC67E：常用汉字，先按笔划再按部首排序。
<p>◆0xC6A1-0xC8FE：保留给使用者自定义字符（造字区）。
<p>◆0xC940-0xF9D5：次常用汉字，亦是先按笔划再按部首排序。
<p>◆0xF9D6-0xFEFE：保留给使用者自定义字符（造字区）。
</ul>
<p>尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。
<p>例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等)也没有收录到Big5之中。
<li><b>GB18030</b>
	<p>GB18030，全称：国家标准GB18030-2005《信息技术中文编码字符集》,支持GB13000及Unicode的全部统一汉字，共收录汉字70244个。
	<p>GB18030主要有以下特点：
		<ul>
			<p>◆	采用多字节编码，每个字可以由1个、2个或4个字节组成。
			<p>◆	编码空间庞大，最多可定义161万个字符。
			<p>◆	支持中国国内少数民族的文字，不需要动用造字区。
			<p>◆	单字节，其值从0到0x7F。
			<p>◆	双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F）。
			<p>◆	四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。
	</ul>
<li><b>Unicode</b>
	<p>Unicode的学名"UniversalMultiple-OctetCodedCharacterSet"，简称为UCS。UCS可以看作是"UnicodeCharacterSet"的缩写。
	<p>Unicode的功用是为每一个字符提供一个唯一的代码（即一组数字）。在表达一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。大概来说，Unicode编码系统可分为编码方式和实现方式两个层次。				
<p>Unicode的编码方式与ISO10646的通用字符集（UniversalCharacterSet，UCS）概念相对应，目前实际应用的Unicode版本对应于UCS-2，使用16位的编码空间,构成基本多文种平面（BasicMultilingualPlane，简称BMP）。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。
<p>Unicode的实现方式称为Unicode转换格式（UnicodeTranslationFormat，简称为UTF）,包括UTF-8、UTF-16、UTF-7、Punycode、CESU-8、SCSU、UTF-32等，这些实现方式有些仅在一定的国家和地区使用，有些则属于未来的规划方式。目前通用的实现方式是UTF-16小尾序（BOM）、UTF-16大尾序（BOM）和UTF-8。
<p>为了识别Unicode文件，Unicode文件以ZEROWIDTHNOBREAKSPACE字符开头。这作为一个“特征符”或“字节顺序标记（byte-ordermark，BOM）”来识别文件中使用的编码和字节顺序。开头字节Charset/encoding,如下：
	<ul>
		<p>EFBBBF：UTF-8
		<p>FEFF：UTF-16/UCS-2,littleendian
		<p>FFFE：UTF-16/UCS-2,bigendian
		<p>FFFE0000：UTF-32/UCS-4,littleendian
		<p>0000FEFF：UTF-32/UCS-4,big-endian
	</ul>
<p>通过ISOC99所要求的__STDC_ISO_10646__宏定义作为信号通知应用程序。__STDC_ISO_10646__的定义用来指出wchar_t是Unicode。精确的值是一个十进制的yyyymmL格式的常数。例如：#define__STDC_ISO_10646__200104L，是为指出wchar_t类型的值是由ISO/IEC10646和到指定的年月为止的所有修正与技术勘误定义的字符编码表示。
<ol>
	<li>UTF-8
		<p>UTF-8是一种针对Unicode的可变长度字符编码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII相容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他储存或传送文字的应用中，优先采用的编码。
		<p>UTF-8使用一至四个字节为每个字符编码：
		<p>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。
		<p>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。
		<p>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。
		<p>其他极少使用的Unicode辅助平面的字符使用四字节编码。
		<p>Unicode在范围D800-DFFF中不存在任何字符，基本多文种平面中约定了这个范围用于UTF-16扩展标识辅助平面（两个UTF-16表示一个辅助平面字符）。任何编码都是可以被转换到这个范围，但在unicode中他们并不代表任何合法的值。
		<p>根据这种方式可以处理更大数量的字符。原来的规范允许长达6字节的序列，可以覆盖到31位元（通用字符集原来的极限）。尽管如此，2003年11月UTF-8被RFC3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF。
		<p>每个使用UTF-8储存的字符，除了第一个字节外，其余字节的头两个位元都是以"10"开始，使文字处理器能够较快地找出每个字符的开始位置。
		<p>Unicode和UTF-8之间的转换关系：
				<p>U-00000000–U-0000007F：0xxxxxxx
				<p>U-00000080–U-000007FF：110xxxxx10xxxxxx
				<p>U-00000800–U-0000FFFF：1110xxxx10xxxxxx10xxxxxx
				<p>U-00010000–U-001FFFFF：11110xxx10xxxxxx10xxxxxx10xxxxxx
				<p>U-00200000–U-03FFFFFF：111110xx10xxxxxx10xxxxxx10xxxxxx10xxxxxx
				<p>U-04000000–U-7FFFFFFF：1111110x10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx
	<p>UCS字符U+0000到U+007F(ASCII)被编码为字节0x00到0x7F（ASCII兼容），这也意味着只包含7位ASCII字符的文件在ASCII和UTF-8两种编码方式下是一样的。所有>U+007F的UCS字符被编码为一个多个字节的串，每个字节都有标记位集。UTF-8以字节为编码单元，它的字节顺序在所有系统中都是一样的，没有字节序的问题。
	<li>UTF-16
		<p>UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS-2，或者UCS-4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。
		<p>UTF-16使用2个或者4个字节来表示字符。根据这两个字节的顺序不同，它又分为UTF-16Little-Endian(低字节在前，高字节在后)和UTF-16big-Endian(高字节在前，低字节在后)。在基本多语言平面内定义的符号，使用2个字节表示，在此之外的字符(其他平面内的字符)，则使用4个字节表示。由于第零平面内，从0xD8到0xDF之间的区段是没有使用的，因此可以利用0xD8-0xDF之间的值来对辅助平面的字符进行编码。
		<p>其编码方法是：	
					<p>1.如果字符编码U小于0x10000,也就是十进制的0到65535之内，则直接使用两字节表示；
					<p>2.如果字符编码U大于0x10000,由于UNICODE编码范围最大为0x10FFFF,从0x10000到0x10FFFF之间共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U'表示从0-0xFFFFF之间的值，将其前10bit作为低位和16bit的数值0XD800进行或操作，将后10bit作为低位和0XDC做或操作，这样组成的4个byte就构成了U的编码。
					<p>UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节（2字节）储存，但UTF-16却无法相容于ASCII编码。
			</ol>
	<h3>FAQ</h3>
		<ol>
			<li>乱码的问题。
					<p>同样的编码在不同的编码表中可能表示不同的字符，就会出现错误的转换，导致乱码。问题的根源在于我们有太多的编码表，如果整个地球村都使用一张统一的编码表，那么每一个编码就会有一个确定的含义，就不会有乱码的问题出现了。Unicode就是这样的一种编码。			
			<li>什么是字库？
					<p>字库是外文字体、中文字体以及相关字符的电子文字字体集合库，字库被广泛用于计算机、网络及相关电子产品上。没有安装相应的编码字符集的字库同样无法显示正确的字符。
		<li>C\C++默认的编码是ANSI。C/C++标准提供了wchat_t关键字来实现对Unicode的支持，而且wchat_t类型只用于Unicode编码(UCS)。在Windows平台下，wchat_t类型是16位的；而在Linux下，wchat_t类型是32位的。示例如下：
			
<pre class="code">
char str[]=“中文123”；sizeof（str）=8；（以’\0’结束）
wchar_t wstr[]=L“中文123”；sizeof（wstr）=12；（以’\0\0’结束）
</pre>					

<li>不同编译器对wchar_t字符和字符串的支持。
	<p>wchar_t的实际定义为：typedefunsignedshortwchar_t;即实际为无符号短整型，因此wchar_t的存储遵循大小端法则。
	<ol>
		<li>VisualC/C++
		<p>VisualC/C++的编译器对Unicode的支持是最完美的。除了完美支持wchar_t类型外，VisualC++7.0或者更新版本的编译器还可以接受UTF-8/UTF-16编码格式的源代码文件。
		<li>BorlandC/C++
			<p>BorlandC/C++的编译器对Unicode的支持也是完美的，从1994年的BorlandC++4.5开始，BorlandC/C++的编译器就能正确处理wchar_t字符和字符串。
			<p>C++Builder6.0的编译器还添加了-CP参数来支持各种不同Codepage的源代码。
			<p>C++Builder2006还可以支持UTF-8编码格式（带BOM）的源代码文件，但是不支持UTF-16编码格式的源代码文件。
		<li>GCC
			<p>GNUC/C++编译器也可以正确支持wchar_t字符和字符串，但是源代码的保存格式必须符合下面条件：
			<ul>
			<p>◆源代码文件的保存编码必须是UTF-8。							
				<p>◆UTF-8编码格式的源代码文件，不能有BOM标志头。		
				</ul>
			<p>只有源代码文件符合上面两个条件，gcc才会正确支持wchar_t字符和字符串。如果不符合上面两个条件的话，有可能会编译出错，有可能会产生错误的wchar_t字符和字符串。
			<p>gcc在Windows平台下，wchar_t是16位类型，在Linux平台下，wchar_t是32位类型。
			<li>DigitalMarsC/C++
				<p>DigitalMarsC/C++的前身是SymantecC/C++。DigitalMarsC/C++也可以正确支持wchar_t字符和字符串。但是DigitalMarsC/C++不能接受UTF-8（带BOM）、UTF-16编码格式的源代码文件。
			<li>OpenWatcomC/C++
				<p>OpenWatcomC/C++不支持wchar_t字符和字符串。虽然OpenWatcomC/C++在处理wchar_t字符和字符串时，不会编译错误，但是所产生的wchar_t字符和字符串却是错误的。
				<p>OpenWatcomC/C++也不能接受UTF-8（带BOM）、UTF-16编码格式的源代码文件。OpenWatcom可以说是对Unicode支持最差的编译器。
			</ol>	

<script>footer("chinese")</script>
</body>
</html>