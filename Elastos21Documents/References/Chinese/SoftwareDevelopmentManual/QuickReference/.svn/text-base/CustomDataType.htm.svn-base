<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>自描述数据类型概述</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>

<body>

<h2>自描述数据类型概述</h2>

    <h3>一个传统的数据定义范例</h3>
        <p>在传统的应用编程习惯中，编程者如果需要确定了一个存储1000个字节的缓存空间通常就简单的定义为：</p>
        <pre class="code">
#define BUFLENGTH 1000
BYTE buf[BUFLENGTH];
</pre>
        <p>开发者在使用该缓存空间时，通常关心的是buf中的实际参与计算的内容，却很少注意buf的自我描述性。在网络计算中，一个没有特征的数据可能增加服务的不必要的负担。对于上面的例子来说，该buf所带信息太少。在将这段数据传递给某个远程服务接口的方法时，为防止内存溢出，必须附带上buf的容量。例如：</p>
        <pre class="code">
ECODE foo(
    BYTE *pBuf,
    INT capacity);
</pre>
        <p>如果该段Buffer中有部分内容正被其他服务使用，而在当前服务中又不希望被覆盖，那么接口方法的实现将声明如下：</p>
        <pre class="code">
ECODE foo(
          BYTE *pBuf,
          INT capacity，
          INT used);
</pre>
        <p>其中used参数表示使用过的字节。我们并不认为这种接口方法的定义是成功的，因为让服务端花费多余的处理来识别后两个参数是资源的一种浪费。而出现这种接口方法的定义，主要原因在于传统的操作系统对于这种常见的参数传递习惯没有定义一种合适的数据类型来处理它。在面向网络的应用程序中，数据应该是自描述的。</p>
    <h3>自描述数据类型</h3>
        <p>通过上一节简单的例子我们可以看到，为传递一个非自描述的数据类型参数，可能需要多个额外的参数加以补充说明。那么什么是自描述的数据类型呢？</p>
        <p>简单的来说，所谓自描述数据类型是指这样的一些数据类型，<b>该数据类型自身所带有数据信息已经足够描述其自身的特征，比如占用内存的情况、它的基本属性及其它的相关信息等，也就是说，不需要其他附加条件也能够实现自我描述的数据类型。</b></p>
        <p>通过该定义，我们基本上可以为传统的数据类型进行分类，如double、float等兼容IEEE实数标准的数据类型就是属于自描述的数据类型。假设服务端获得一个double的参数传递，那就能够确定：①现在得到的是一个占8个字节的连续内存区域；②共64位；③其中第一位是符号位，11位是指数位，52位是尾数位；④它的范围为+/-1.7E308。这些信息是很明确的，也足够描述该数据类型的特征。再比如说如果传递的是char&nbsp;*指针类型的参数，那么我们可以知道这是一个32位的指针，它指向一个以字节为单位的连续的字符缓存空间，该连续空间以‘\0’表示结束。那么我们可以得到该连续字符空间的起始地址及结束地址，也就可以得到该字符串的长度，因此，我们也说char&nbsp;*是属于自描述的数据类型。如果是byte&nbsp;*或void&nbsp;*/PVOID的数据类型呢？可以肯定的是，这些不属于自描述的数据类型，因为他们自身所携带的信息不足以描述他们的自身，这在上例中已有所说明。</p>
        <p>非指针型基础数据类型基本上属于自描述类型，除了字符指针外，其他基础数据类型的指针类型基本上不属于自描述数据类型。</p>
        <p>另外，C/C++除了这些基础数据类型外，同时还支持用户自定义数据类型，例如：</p>
        <pre class="code">
typedef class CStudent CStudent ,*pStudent;

class CStudent{
    BYTE  *pData;
public:
    INT age;
    Char *pClassName;
};
</pre>
        <p>就这个例子而言，CStudent及pStudent都不属于自描述数据类型，其成员pData不具有描述自身的特性。如果我们略加修改为：</p>
        <pre class="code">
typedef class Cstudent Cstudent, *pStudent;

class Cstudent {
    INT dataLen;
    BYTE  *pData;
public:
    INT age;
    Char *pClassName;
};
</pre>
        <p>其中新增的成员变量dataLen将用于记录pData的大小。那么从某种程度上的应用来说这就基本符合了自描述数据类型的要求（但这不能够作为操作系统的自描述基本数据类型，因为这毕竟是用户自定义的，操作系统无从得知用户的约定）。从这里我们可以看出，就应用而言，自描述数据类型是相对于需求的。在实际应用开发中，我们要依据需求通过最简练的设计包容最有效的信息，当然无需刻意追求一种自描述的效果而矫枉过正，因为实现自描述需要额外的系统存储资源。</p>

    <h3>自描述数据类型在CAR构件开发中的重要性</h3>
    <p>基础自描述数据类型在传统开发中并不能很好的体现它的优势，因为在传统的单道程序或“客户/服务器”（C/S）二层体系结构设计中，对数据是否自描述没有太多要求，它可以通过用户的自我约定及额外的参数传递来解决这个问题，而且对于二层体系结构来说它在资源上的消耗是微乎其微的。</p>
    <p>但在网络技术迅猛发展的今天，“客户/中间件/服务器”三层乃至所谓的多层体系结构、中间件技术、Grid网络计算等新概念新技术层出不穷，传统的操作系统已不能很好的适应WEB服务的要求，而基于构件技术的Elastos正是为适应这种新形式而研发出来的新一代操作系统。我们知道，在中间件的应用开发中，构件接口参数的列集（Marshaling）和散集（UnMarshaling）起着关键性的作用，除了整型和布尔型这类的简单类型能被顺利处理外，其他部分的复杂类型则将消耗系统的很大一部分资源用于处理传递参数的列集和散集。而定义出一套基础自描述数据类型将使我们在以下方面获利：</p>
    <ul>
        <li>可以通过有限的参数传递，得到理想的数据信息；
        <li>能有效地降低服务构件的负载，并能快速响应客户构件的应用请求；
        <li>能有效地减少数据的二义性，避免发生人为的不必要的计算错误；
        <li>在CAR技术中，满足构件兼容性的要求。
    </ul>



<script>footer("KoreTide")</script>
</body>
</html>