<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=GB2312">
<title>Stream IO API: IInputStream接口参考</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script src="../../../xsl/docstyles_for_doxgen.js"></script></head><body>
<!-- 制作者 Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>首页</span></a></li>
    <li class="current"><a href="annotated.html"><span>类&接口</span></a></li>
    <li><a href="examples.html"><span>示例</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>组合类型列表</span></a></li>
    <li><a href="hierarchy.html"><span>类继承关系</span></a></li>
    <li><a href="functions.html"><span>组合类型成员</span></a></li>
  </ul>
</div>
<h1>IInputStream接口参考</h1><!-- doxytag: class="IInputStream" -->该接口表示基本输入流,用于从二进制流中读取输入字节。
<a href="#_details">更多...</a>
<p>
<div class="dynheader">
继承图，类IInputStream</div>
<div class="dynsection">
<p><center><img src="interface_i_input_stream__inherit__graph.png" border="0" usemap="#_i_input_stream__inherit__map" alt="Inheritance graph"></center>
<map name="_i_input_stream__inherit__map">
<area shape="rect" href="interface_i_a_string_input_stream.html" title="该接口表示字符串输入流，在该流中读取的字节由字符串内容提供。..." alt="" coords="5,80,147,107"><area shape="rect" href="interface_i_data_input_stream.html" title="数据输入流接口,该接口允许应用程序以与机器无关的方式从输入流中读取各..." alt="" coords="171,80,296,107"><area shape="rect" href="interface_i_file_input_stream.html" title="该接口表示从文件系统中的某个文件中获取的文件输入流，用于读取诸如图?." alt="" coords="320,80,440,107"><area shape="rect" href="interface_i_w_string_input_stream.html" title="该接口表示宽字符串输入流，在该流中读取的字节由字符串内容提供。..." alt="" coords="464,80,611,107"></map>
</div>

<p>
<a href="interface_i_input_stream-members.html">所有成员的列表。</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>公有成员</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#863223639947eb15ea38a66f1e1f63fe">Available</a> ([out] Int32 *bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">用于获取该方法的下一个调用方可以不受阻塞地从此输入流读取 (或跳过)的字节数。  <a href="#863223639947eb15ea38a66f1e1f63fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60c62a83d6b8f3c6d55dd665bcb6226a"></a><!-- doxytag: member="IInputStream::Close" ref="60c62a83d6b8f3c6d55dd665bcb6226a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#60c62a83d6b8f3c6d55dd665bcb6226a">Close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">关闭此输入流并释放与该流关联的所有系统资源。 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193">Mark</a> ([in] Int32 readLimit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">在此输入流中标记当前的位置。  <a href="#c3ba20b77f44eb6d9d6a9e6bc0712193"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#1f908d8c0fff4e2fbc469c1f9251e79a">IsMarkSupported</a> ([out] Boolean *supported)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">测试此输入流是否支持 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 和 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 方法。  <a href="#1f908d8c0fff4e2fbc469c1f9251e79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#9699c72cc74f6118d0ff2a2a231dd792">Read</a> ([out] Byte *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">从输入流读取下一个字节数据。  <a href="#9699c72cc74f6118d0ff2a2a231dd792"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#93dff50df17e9e4556d9583ac790c406">ReadBuffer</a> ([out] BufferOf&lt; Byte &gt; *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">从输入流中读取一定数量的字节并将其存储在缓冲区中。  <a href="#93dff50df17e9e4556d9583ac790c406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#3464fb6270ce367c5742680ce5d67953">ReadBufferEx</a> ([in] Int32 offset,[in] Int32 length,[out] BufferOf&lt; Byte &gt; *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将输入流中最多 length 个字节的数据读入字节数组。  <a href="#3464fb6270ce367c5742680ce5d67953"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8">Reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">将此流重新定位到对此输入流最后调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 方法时的位置。  <a href="#425b81389be853a13228a266434e9cb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_input_stream.html#c9d9d3caa4a1bf96335e659d68f04f26">Skip</a> ([in] Int32 length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">跳过和放弃此输入流中的len个字节的数据。  <a href="#c9d9d3caa4a1bf96335e659d68f04f26"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>详细描述</h2>
该接口表示基本输入流,用于从二进制流中读取输入字节。 <hr><h2>成员函数文档</h2>
<a class="anchor" name="863223639947eb15ea38a66f1e1f63fe"></a><!-- doxytag: member="IInputStream::Available" ref="863223639947eb15ea38a66f1e1f63fe" args="([out] Int32 *bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::Available           </td>
          <td>(</td>
          <td class="paramtype">[out] Int32 *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
用于获取该方法的下一个调用方可以不受阻塞地从此输入流读取 (或跳过)的字节数。
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>- 可以不受阻塞地从此输入流读取 (或跳过)的字节数。 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3ba20b77f44eb6d9d6a9e6bc0712193"></a><!-- doxytag: member="IInputStream::Mark" ref="c3ba20b77f44eb6d9d6a9e6bc0712193" args="([in] Int32 readLimit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::Mark           </td>
          <td>(</td>
          <td class="paramtype">[in] Int32&nbsp;</td>
          <td class="paramname"> <em>readLimit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
在此输入流中标记当前的位置。
<p>
对 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 方法的后续调用会在最后标记的位置重新定位此流，以便后续的读取操作重新读取相同的字节。 <dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>readLimit</em>&nbsp;</td><td>- 此参数用于告知此输入流在标记位置失效之前允许读取的字节数。</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>如果方法 <a class="el" href="interface_i_input_stream.html#1f908d8c0fff4e2fbc469c1f9251e79a" title="测试此输入流是否支持 Mark() 和 Reset() 方法。">IsMarkSupported()</a> 返回 True，则输入流总会在调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 之后记住所有读取的字节，并且无论何时调用方法 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> ，都会准备再次提供那些相同的字节。但是，如果在调用 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 之前可以从流中读取多于 readlimit 的字节，则根本不需要该流记住任何数据。 </dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a>； <a class="el" href="interface_i_input_stream.html#1f908d8c0fff4e2fbc469c1f9251e79a" title="测试此输入流是否支持 Mark() 和 Reset() 方法。">IsMarkSupported()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1f908d8c0fff4e2fbc469c1f9251e79a"></a><!-- doxytag: member="IInputStream::IsMarkSupported" ref="1f908d8c0fff4e2fbc469c1f9251e79a" args="([out] Boolean *supported)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::IsMarkSupported           </td>
          <td>(</td>
          <td class="paramtype">[out] Boolean *&nbsp;</td>
          <td class="paramname"> <em>supported</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
测试此输入流是否支持 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 和 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 方法。
<p>
无论是否支持 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 和 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 都是特定输入流实例的不变属性。<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>supported</em>&nbsp;</td><td>- 如果此输入流支持 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 和 <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> 方法，则为True；否则为False。</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a>； <a class="el" href="interface_i_input_stream.html#425b81389be853a13228a266434e9cb8" title="将此流重新定位到对此输入流最后调用 Mark() 方法时的位置。">Reset()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9699c72cc74f6118d0ff2a2a231dd792"></a><!-- doxytag: member="IInputStream::Read" ref="9699c72cc74f6118d0ff2a2a231dd792" args="([out] Byte *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::Read           </td>
          <td>(</td>
          <td class="paramtype">[out] Byte *&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
从输入流读取下一个字节数据。
<p>
如果因已到达流末尾而没有可用的字节，则返回值 -1。<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>- 读入数据的字节缓冲区。</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#93dff50df17e9e4556d9583ac790c406" title="从输入流中读取一定数量的字节并将其存储在缓冲区中。">ReadBuffer()</a>； <a class="el" href="interface_i_input_stream.html#3464fb6270ce367c5742680ce5d67953" title="将输入流中最多 length 个字节的数据读入字节数组。">ReadBufferEx()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="93dff50df17e9e4556d9583ac790c406"></a><!-- doxytag: member="IInputStream::ReadBuffer" ref="93dff50df17e9e4556d9583ac790c406" args="([out] BufferOf&lt; Byte &gt; *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::ReadBuffer           </td>
          <td>(</td>
          <td class="paramtype">[out] BufferOf&lt; Byte &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
从输入流中读取一定数量的字节并将其存储在缓冲区中。
<p>
如果缓冲区的长度为 0，则无字节可读且返回 0；否则，要尝试读取至少一个字节。如果因为流位于文件末尾而没有可用的字节，则返回值 -1；否则，至少可以读取一个字节并将其存储在缓冲区中。<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>- 存储读入数据的缓冲区。</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#9699c72cc74f6118d0ff2a2a231dd792" title="从输入流读取下一个字节数据。">Read()</a>； <a class="el" href="interface_i_input_stream.html#3464fb6270ce367c5742680ce5d67953" title="将输入流中最多 length 个字节的数据读入字节数组。">ReadBufferEx()</a> </dd></dl>
<dl compact><dt><b>示例: </b></dt><dd>
<a class="el" href="_file_i_o_8cpp-example.html#a4">FileIO.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="3464fb6270ce367c5742680ce5d67953"></a><!-- doxytag: member="IInputStream::ReadBufferEx" ref="3464fb6270ce367c5742680ce5d67953" args="([in] Int32 offset,[in] Int32 length,[out] BufferOf&lt; Byte &gt; *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::ReadBufferEx           </td>
          <td>(</td>
          <td class="paramtype">[in] Int32&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] Int32&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out] BufferOf&lt; Byte &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将输入流中最多 length 个字节的数据读入字节数组。
<p>
如果 length 为 0，则没有字节可读且返回 0；否则，要尝试读取至少一个字节。如果因为流位于文件末尾而没有可用的字节，则返回 -1。<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>- 表示缓冲区的初始偏移量，方法将在此处开始写入所读取的数据。 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>- 表示要读取的最大字节数。 </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>- 表示存储读入数据的缓冲区。</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#9699c72cc74f6118d0ff2a2a231dd792" title="从输入流读取下一个字节数据。">Read()</a>； <a class="el" href="interface_i_input_stream.html#93dff50df17e9e4556d9583ac790c406" title="从输入流中读取一定数量的字节并将其存储在缓冲区中。">ReadBuffer()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="425b81389be853a13228a266434e9cb8"></a><!-- doxytag: member="IInputStream::Reset" ref="425b81389be853a13228a266434e9cb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::Reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
将此流重新定位到对此输入流最后调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 方法时的位置。
<p>
<dl class="note" compact><dt><b>注解:</b></dt><dd>如果方法 <a class="el" href="interface_i_input_stream.html#1f908d8c0fff4e2fbc469c1f9251e79a" title="测试此输入流是否支持 Mark() 和 Reset() 方法。">IsMarkSupported()</a> 返回 True，则：最近调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 以来读取的所有字节将重新提供给 <a class="el" href="interface_i_input_stream.html#9699c72cc74f6118d0ff2a2a231dd792" title="从输入流读取下一个字节数据。">Read()</a> 方法的后续调用方。 如果创建流以来未调用方法 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a>，或最后调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 以来从该流读取的字节数大于最后调用 <a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> 时的参数，则调用出错；如果方法 <a class="el" href="interface_i_input_stream.html#1f908d8c0fff4e2fbc469c1f9251e79a" title="测试此输入流是否支持 Mark() 和 Reset() 方法。">IsMarkSupported()</a> 返回 False，则：将该流重新设置为一种固定状态，该状态取决于输入流的特定类型和其创建方式的固定状态。提供给后续 <a class="el" href="interface_i_input_stream.html#9699c72cc74f6118d0ff2a2a231dd792" title="从输入流读取下一个字节数据。">Read()</a> 方法的调用方的字节取决于特定类型的输入流，或调用出错。 </dd></dl>
<dl class="see" compact><dt><b>参见:</b></dt><dd><a class="el" href="interface_i_input_stream.html#c3ba20b77f44eb6d9d6a9e6bc0712193" title="在此输入流中标记当前的位置。">Mark()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9d9d3caa4a1bf96335e659d68f04f26"></a><!-- doxytag: member="IInputStream::Skip" ref="c9d9d3caa4a1bf96335e659d68f04f26" args="([in] Int32 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IInputStream::Skip           </td>
          <td>(</td>
          <td class="paramtype">[in] Int32&nbsp;</td>
          <td class="paramname"> <em>length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
跳过和放弃此输入流中的length个字节的数据。
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>- 表示要跳过的字节数。</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>注解:</b></dt><dd>出于各种原因，该 <a class="el" href="interface_i_input_stream.html#c9d9d3caa4a1bf96335e659d68f04f26" title="跳过和放弃此输入流中的len个字节的数据。">Skip()</a> 方法跳过某些小于len的字节数 (可能是 0)后结束。这可能由多种原因引起，在跳过len个字节之前已到达文件的末尾只是其中的一种可能。如果len为负，则不跳过任何字节。 </dd></dl>

</div>
</div><p>
<script>footer("chinese")</script>
</body>
</html>
