<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
    <title>可重用性</title>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <script src="/xsl/docstyles.js"></script>
</head>

<body>
<h2>可重用性</h2>
    <p>与所有面向对象的系统一样，CAR构件的可重用性是其很重要的一个特性。与C++类在源代码级别的重用不同，CAR构件的重用是建立在对二进制代码重用的基础上的。具体包括<a class="style1" href="#包容">包容（containment）</a>、<a class="style1" href="#聚合">聚合（aggregation）</a>以及<a class="style1" href="inheritance/inheritance.htm">二进制继承</a>三种重用模型，其本质也都是在一个构件中对另外一个构件的使用。</p>
    <p>在包容机制中，外部构件除了实现自己的接口外，还包含了指向内部构件所有接口的指针，使内部构件接口相对于外部构件的客户是不可见的，只有通过外部构件提供的接口才能间接完成对内部构件接口的调用，并以此实现对已有构件的重用。由于包容机制为内部构件接口提供了外部接口实现，因此可以通过在外部接口添加适当的代码来完成与被重用构件所提供服务类似的功能。这有些类似于对C++类虚函数的重载。</p>
    <p>聚合机制的本质其实就是包容，只不过是其一个特例而已。采用聚合机制的构件并没有实现用于转发给内部构件接口的接口，而是直接将客户发出的对内部构件接口的请求直接传递给内部构件的接口，使内部构件接口直接暴露于外部构件的客户。但客户在请求到此接口指针并对其接口进行调用时，仍不会意识到被重用构件的存在，因此只能实现与被重用构件所提供服务完全一样的重用功能。与包容不同，并不是所有的构件都能够支持聚合。至于在重用时是采取包容机制还是聚合机制，关键在于要实现的功能与待重用的组件所提供服务是类似还是完全一致。</p>
    <center><img src="images/model.jpg"></center>
    <center>包容与聚合重用模型</center>
    <p>构件继承机制可以做到二进制构件间的继承、重载等，并且可以灵活地进行构件复用。该机制有点类似C++语言中类的继承，虚函数的重载等特性，基构件调用虚接口方法可以跳到相应派生构件的接口方法中执行，派生构件可以直接重载和调用继承于基构件的接口方法。只是在构件继承机制中是二进制构件间的继承、重载，而在C++语言中是C++源代码的继承、重载。</p>

<script>footer("chinese")</script>
</body>
</html>