<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
    <title>与构件继承机制类似的现有技术</title>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
    <script src="/xsl/docstyles.js"></script>
</head>

<body>
    <h2>与构件继承机制类似的现有技术</h2>
        <ol>
            <li><h3>C++虚函数</h3>
                <p>C++的虚函数实现了面向对象的运行时多态性。运行时，在基类里调用虚函数，会跳到其派生类的方法中执行；派生类可以重载和调用其父类的虚函数。与其对应，</span>CAR<span lang="ZH-CN">构件继承机制中，基构件调用虚接口方法可以跳到相应派生构件的接口方法中执行，派生构件可以直接重载和调用继承于基构件的接口方法。两者最大的区别是，C++的虚函数技术是基于C++类的源代码级别的继承与重载机制，而CAR的继承机制是基于构件的二进制级别的继承与重载机制。</p>
                <p>构件二进制继承与重载的优点是不需要暴露基构件的实现细节，基构件具有完全的封装性，同时又能实现二进制构件的多态性。</p>
            <li><h3>构件包容技术</h3>
                <p>包容是最简单的构件复用方法，但包容不能重写被包容对象的接口方法实现，只能在外面“包一层”。不能实现多态性。</p>
                <center><img src="images/contain.jpg"></center>
                <p>从以上示意图可以看到，对象A没办法调用到对象B的ISomeInterface接口，对象B只能从外面修改ISomeInterface接口的实现。这样就没办法做到多态性。</p>
            <li><h3>构件聚合技术</h3>
                <p>聚合也是构件复用的一种方式。但只是把被聚合对象的接口直接暴露给外面，聚合对象没有机会改变被聚合对象的接口方法实现，只是让外界看起来像一个大对象。</p>
                <center><img src="images/cluster.jpg"></center>
                <p>从以上示意图可以看出，对象A的ISomeInterface接口直接暴露在外面，对象B没有修改ISomeInterface接口实现的机会。可见，这种构件复用方式也不能做到多态性。</p>
                <p>总之，C++的虚函数技术可以做到多态性，但只是源代码级别的继承与重载，必须暴露基类的数据结构，违反了封装性；包容与聚合都是构件复用的一种方式，构件具有很好的封装性，但包容与聚合无法做到多态性。而构件继承技术就是为了解决以上问题而发明的。</p>
                <center><img src="images/inherit.jpg"></center>
                <p>可以调用到其派生类对象B的ISomeInterface接口。也就是说，对象B有机会可以”改变”ISomeInterface的实现。这就可以做到构件的多态性了。</p>

        </ol>
        
<script>footer("chinese")</script>
</body>
</html>
