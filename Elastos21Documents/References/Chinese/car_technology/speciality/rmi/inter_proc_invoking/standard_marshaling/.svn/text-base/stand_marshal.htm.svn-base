<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>标准列集/散集</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>

<body>
<h2>标准列集/散集</h2>
    <h3>标准列集/散集的概念及简介</h3>
        <p>CAR（Component&nbsp;Application&nbsp;Runtime）是科泰世纪公司拥有自主知识产权的构件技术。CAR构件技术支持远程接口调用，即允许构件服务和构件服务调用者处于操作系统的不同地址空间，这两个不同空间之间不允许彼此直接访问或者具有不同的访问权限。这个时候就需要某种通讯机制来实现不同地址空间之间的数据交互，这个过程被定义为CAR构件调用数据的列集/散集过程。</p>
        <p>CAR构件技术支持远程接口的自动列集/散集机制（即标准marshaling/unmarshaling）。标准列集/散集机制提供了一套标准的列集/散集过程。通过该机制可以对CAR调用的各种类型的数据进行不同地址空间数据交互，而用户却如同在同一地址空间里面使用构件，透明地进行远程接口调用，也就是说该机制完全向用户屏蔽了底层使用标准列集/散集的过程。 </p>
    <h3>标准列集/散集机制的特点</h3>
        <p>CAR的远程接口标准列集/散集在构件调用过程中的地位类似于COM的自动列集/散集，完成了不同地址空间之间CAR的调用数据地传递和交互。它具有如下的特点：</p>
        <ul>
            <li>CAR的标准列集/散集相对于用户而言是完全透明的。用户如果采用默认的列集/散集过程，使用一个远程接口就如同使用一个本地接口一样，完全屏蔽了数据交换，传递的过程。
            <li>CAR的标准列集/散集是通过在程序运行过程中动态生成存/代理而实现的，摒弃了COM通过静态编译生成存根代理构件的方式。静态编译生成存根/代理常常会引起代码量增大，代码逻辑复杂等问题。
            <li>CAR的标准列集/散集过程中嵌入了对用户自定义列集/散集的支持，用户可以通过标准列集/散集实现对自定义列集/散集的支持，从而满足用户较为特殊的要求。Elastos构件平台通过这项技术实现了跨机器的基于soap协议的web&nbsp;service服务。
            <li>CAR的标准列集/散集主要用于Elastos操作系统上针对一些内核系统功能，也是通过构件技术而引出的。为了提高远程调用的效率，CAR的标准列集/散集根据服务构件以及构件调用者所处地址空间的关系进行了不同的分类处理，根据用户端和服务器端所在地址空间的不同列集/散集分为如下几种：
                <table>
                    <thead>
                        <td></td>
                        <td>用户端</td>
                        <td>服务器端</td>
                    </thead>
                    <tr>
                        <td>第一种情况</td>
                        <td>进程A空间</td>
                        <td>进程B空间</td>
                    </tr>
                    <tr>
                        <td>第二种情况</td>
                        <td>同进程用户空间</td>
                        <td>同进程内核空间</td>
                    </tr>
                    <tr>
                        <td>第三种情况</td>
                        <td>同进程内核空间</td>
                        <td>同进程用户空间</td>
                    </tr>
                </table>
                <p>对于这三种情况，由于各自所处空间的差异以及空间之间传递数据的策略不同，对于列集和散集的过程也有所不同。CAR标准列集/散集机制通过采取不同的列集散集方式来满足不同的数据保护需求，并尽可能地提高系统运行效率，尤其是内核以接口形式导出的功能的效率。</p>
            <li>CAR的标准列集/散集支持以类为单位的列集/散集，这有别于COM的以接口为单位的列集/散集。在传统方式中，接口只是提供了构件与外部的交换形式，而类则作为实现接口的载体，以类为单位的构件可以允许一个类中实现多个接口。从远程接口的标准列集/散集的实现来看，既可以选择以类为单位进行列集/散集，又可以选择以接口为单位进行列集散集。Elastos操作系统构件平台技术选择以类为单位进行远程接口的自动列集/散集的实现，主要是因为用户常常通过Probe获得同一实现类的构件接口。如果采用以接口为单位的方式进行自动列集/散集，就不免要远程获取数据，重新建立存根/代理，并返回相应的接口代理给用户。而远程地获取数据，尤其是在分布式环境的情况下是非常耗时的，这样就促使我们必须尽可能少地跨远程获取数据，每次获取都尽量带够足够多的信息。以类为单位就符合这种理念，当用户通过Probe获取接口的时候，所有的处理都在客户端进行。另外在现实的实现中，往往都采用以构件类为最小的生命周期管理单位，所有对于接口的生命周期管理最后都会归结到对接口所在的实现构件类的引用计数的操作和处理，因而采用以类为单位实现远程接口的自动列集/散集更加符合现实的构件生命周期管理模型。类似于Probe，以类为单位的列集/散集对于接口的生命周期管理也可减少跨空间的调用。从实现角度来看，以类为单位并不会付出太多的代价。
        </ul>
    <h3>标准列集/散集的使用方式</h3>
        <p>Elastos构件平台允许通过<a class="style1" href="../../../naming_service/naming_service.htm">命名服务</a>或者<a class="style1" href="../../../../../SoftwareDevelopmentManual\CoreServices\CARServices/BasicCAR.htm">相关API</a>获得一个远程构件指针。用户可以通过命名服务发布一个远程构件服务。具体操作请参见<a class="style1" href="../../../../../SoftwareDevelopmentManual\CoreServices\CARServices\NamingService.htm">命名服务</a>以及CAR&nbsp;API的相关文档。</p>


<script>footer("chinese")</script>
</body>
</html>