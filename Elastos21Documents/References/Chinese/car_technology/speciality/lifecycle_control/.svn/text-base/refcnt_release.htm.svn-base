<html>

	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>refcnt_release</title>
	</head>

	<body>
		<h2>引用计数粒度</h2>
		  <P>采用引用计数管理对象的生命周期涉及到一个计数粒度的问题，即在什么层次上对对象进行引用计数。主要有三个层次：</P>
		<h3>1.接口级</h3>
      <P>由于car构件对象需要通过接口指针访问，因此接口级引用计数表示对对象的每个接口单独计数。例如，如果一个对象可以暴露出两个接口，则这个对象有两份引用计数，分别记录每个接口被引用的情况。</P>
      <P>接口级引用计数的优势在于可以有效地掌握客户程序对接口的使用情况，这对于调试构件程序和分析客户程序的使用情况非常有帮助。</P>
		<h3>2.对象级</h3>
		  <P>顾名思义，对象级引用计数是对每个对象保存一个引用计数，而不论该对象对外暴露出几个接口。显然，对象级引用计数能够准确的反映出对象被引用的情况。</P>
		<h3>3.构件级</h3>
		  <P>构件级引用计数是用一个针对整个构件（以dll文件格式存在）的全局变量来记录引用情况。当构件被加载进内存时，计数值为0；当构件中的某个对象被创建时，计数值加1。在构件被使用的过程中，计数始终是正整数。当某个构件对象被释放时，计数值减1。当所有构件对象都被释放后，计数值回到0，这时该构件将被清除出内存。</P>

		  <P>一般的，计数粒度越细，则越能及时释放无用对象，提高系统的资源利用率；而计数粒度越粗，则越能减少上下层对象间因引用计数值变化而引起的数据通信，从而提高程序运行效率。Car构件模型采用将对象级与构件级相结合的双引用计数法来实现引用计数。开发人员是否只要关心对象级引用计数即可？图5-1为在CAR构件各个层次上使用引用计数的示意图。</P>
		  <center><img src="images/lifecycle1.JPG"/></center>
		  <center>图5-1</center>
<pre>





</pre>
	</body>

</html>