<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>circular_handle</title>
	</head>

	<body>
		<h2>循环引用的处理</h2>
		  <P>解决循环引用可以选用三种不同的方法：不调用AddRef、显示地终止一个构件或使用另一个构件。</P>
		<H3>方法一：不调用AddRef</H3>
		  <P>这种方法实际是不对循环引用中的接口进行引用计数。对于在<a class="style1" href= "circular_introduce.htm">上一节</a>中提到的B构件，我们就可以使用此种方法。B构件并没有调用A构件传给它的IA接口指针上的AddRef。由于B构件知道它是包含在A构件的生命期内的，因此只要确信它仍活着，A构件一定也活着，因而后项指针也将是有效的。</P>
		  <P>这种技术的使用是非常频繁的，因此我们可以给它定义一个相应的名称。对于一个没有被进行引用计数的接口的引用被称作是一个<B>弱引用</B>。弱引用不会将一个构件保持在内存中。与此相对，强引用指的是被进行引用计数的引用，这种类型的引用可以把构件保存在内存中。</P>
		  <P>虽然此种方法最为简单，但并不是在所有的情况下都能使用它。具有指向另外一个构件的弱引用的构件需要知道此引用何时将成为无效的。上面的构件B因其生命期包含在构件A的生命期内，因此无需关心这个问题。但若两个构件的生命期没有嵌套，则需要另外一种方式来只是这一点。</P>
		<H3>方法二：强制释放对象</H3>
		  <P>打破循环引用的另外一种方法是给两个构件中的某一个(或两个)提供一种将另外一个构件显示终止的方法。此时构件将不再等待被引用的构件的引用计数值变为0，而是告诉此构件释放它的所有接口指针。这一点可以通过建立一个新的具有能够将构件终止的接口而方便地加以实现。图5-3为显示终止示意图</P>
		  <center><img src="images/lifecycle3.JPG"/></center>
		  <center>图5-3</center>
		<H3>方法三：使用一个单独的构件</H3>
		  <P>还有一种方法是给循环中的某个构件提供一个单独的对象或子构件。此子构件将维护一个对其外部对象的一个弱引用。</P>
		  <P>子构件是避免出现循环引用的最为灵活的方法。此时程序员无需构件的源代码或关于构件的其它一些额外知识，只需知道支持实现子构件的接口即可。插入一个具有弱引用的子构件将可以避免出现循环引用。 </P>
<pre>





</pre>
	</body>
</html>