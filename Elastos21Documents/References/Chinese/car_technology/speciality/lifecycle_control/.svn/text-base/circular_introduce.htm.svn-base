<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>circular_introduce</title>
	</head>

	<body>
		<h2>循环引用</h2>
		  <P>基于引用计数的对象生命周期管理方法存在一个缺陷，即无法释放相互间循环引用的对象。</P>
		  <P><B>循环引用</B>是指两个car构件对象间相互保留着对方的引用。由于其中任何一方都只会在自己被释放的情况下才释放对方的引用，没有任何一方主动释放自己，从而造成死锁状态导致双方都无法被释放。图5-2所示的两个构件间就存在这样一种循环引用现象。</P>
		  <center><img src="images/lifecycle2.JPG"/></center>
		  <center>图5-2</center>
		  <P>如上图所示，假定构件A创建一个构件B，并获取一个IB接口指针，然后此指针调用AddRef。A构件也将把它的IA接口传递给B，后者将调用此接口上的AddRef。这样构件B和构件A的引用计数均将至少为1。</P>
		  <P>当构件A结束对构件B的调用，其将在析构函数中释放IB(此析构函数将在构件的引用计数值为0时被调用)。但构件A具有一个指向构件B的IA接口指针，它只是在此引用计数值为0时才释放此接口。这样将会导致一个死锁：构件A将只是在构件B释放了它之后才释放构件B，而构件B也将只在构件A释放了它之后才释放A，从而两个构件都将得不到释放。</P>
		  <P>循环引用与引用计数的作法是有冲突的，因为如若在循环引用的情况下仍旧遵守引用计数规则，势必会使一些构件永远得不到释放。从上例可知，在CAR构件对象间存在循环引用的现象，为了让使用完毕的对象能被正常释放，必须使用一些方法解决循环引用问题。</P>
<pre>





</pre>
	</body>
</html>