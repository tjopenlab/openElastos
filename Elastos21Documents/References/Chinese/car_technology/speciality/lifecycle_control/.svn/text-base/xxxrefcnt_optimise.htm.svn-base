<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>refcnt_optimise</title>
	</head>

	<body>
		<h2>AddRef及Release调用优化</h2>
		  <P>上节中的这些规则是引用计数的一般规则，只要协作开发的每个程序员都遵照这些规则，那么对接口指针的使用一般不会引起问题。但使用这些规则可能使得在程序代码中频繁地调用AddRef和Release函数，从而降低程序运行效率。因此，在某些特殊情形下，我们可以省略对AddRef或Release的调用。</P>
		  <p><B>情形一：</B>当一个接口指针的生命期包含于另一接口指针的生命期时，只需对外层的那个指针做引用计数。</p>
		  <P>为说明这个问题我们以下面这段代码为例：</P>
<pre class=code>
{
        ………
    IHello * pHello2 = pHello;
    
    pHello2 -> AddRef();  //可省略
    
    pHello -> Hello();
    pHello2 -> Hello();
    
    pHello2 -> Release();  //可省略
    
    pHello ->Relaease();
    ………
}
</pre>
		  <P>对于上面这段代码，只有当用户将pHello释放时构件才会在内存中被删除。而用户只有在用完了pHello和pHello2之后才会将pHello释放。因此可以保证在pHello2的生命期内相应构件将一直存于内存中。所以对pHello的单个引用计数就已足够，pHello2并不真的需要调用AddRef和Release。</P>
		  <P>如若以下段代码为例，pHello2的生命期不包含在pHello的生命期内，则必须对pHello2进行引用计数。</P>
<pre class=code>
{
        ………
    IHello * pHello2 = pHello;
    
    pHello2 -> AddRef();  //不可省略
    
    pHello -> Hello();
    pHello ->Relaease();
    
    pHello2 -> Hello();
    pHello2 -> Release();  //不可省略
    ………
}
</pre>
      <p><B>情形二：</B>当两个接口指针同时指向一个对象时，可以省略对其中一个指针的引用计数。</p>
      <P>在下面这段代码中，通常我们会省略被注释的代码，因为它们都指向同一个对象。</P>
<pre class=code>
IFoo * pFoo;
Func1()
{
    CBar::New(&pBar);
    pFoo = IFoo::Probe(pBar);
    // Foo->AddRef();
    // pBar->Release();
}
Func2()
{
    pFoo->Release();
}
</pre>
    <H3>注意</H3>
      <P>对于存在聚合或者继承关系的对象接口，对上例中省略代码的操作就要十分谨慎了。如果是这样一种情况：</P>
<pre class=code>
{
    ......
    Class CFooBase {
      Interface IFoo;
    }
    
    Class CBar : CFooBase {
      Interface IBar;
    }
}
</pre>
      <P>或者这样一种情况：</P>
<pre class=code>
{         
    ......    
    Aspect AFoo {
      Interface IFoo;
    }
    
    [aggregate(AFoo)]
    Class CBar {
      Interface IBar;
    }
}
</pre>
      <P>对于以上两种情况，我们在对象的过程使用中就不能省略那两句被注释的代码，因为pFoo和pBar指向的是两个对象，对其中一个的AddRef操作不会作用到另一个身上，如果还如之前一样省略代码，会导致因CBar没被释放而内存泄漏，而pFoo被多释放一次（导致pFoo非预期情况下变成无效指针）。</P>
<pre>





</pre>
	</body>
</html>