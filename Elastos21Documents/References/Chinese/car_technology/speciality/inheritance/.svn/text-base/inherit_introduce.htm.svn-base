<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>inherit_introduce</title>
	</head>

	<body>
		<h2>构件继承介绍</h2>
		<h3>基于接口的继承</h3>
		  <P>C++等面向对象语言的继承是基于源代码的继承，即派生类必须获得基类的具体实现才能继承它。这样就造成派生类对基类的过渡依赖。如果基类的成员发生变化，则派生类需要进行重新编译。</P>
		  <P>而car构件模型的继承是基于接口的继承。在CAR构件的继承中，基类和派生类可以分属不同的构件dll，派生类针对特定的构件类进行继承，对其重载和复用都是基于接口来完成。即C++的继承是派生类实现的某个成员方法替代基类的成员方法，而CAR构件继承是派生类实现的某个接口替代基类的接口；C++的继承中，派生类通过调用基类的方法来复用基类的实现，CAR构件继承是派生类调用基类的接口来复用其实现。整个继承都是基于接口的，所以，CAR构件的继承和面向接口的构件编程一样，只依赖于接口，与实现代码无关。</P>
		<h3>继承机制特性</h3>
		<h4>1.复用基类已有实现</h4>
		  <P>实现“复用基类已有实现”。类似于在C++的派生类里调用基类的方法，或者通过派生类对象的指针调用基类的方法。即实现下面代码片断所示的功能：</P>
<pre class= code>
第一种形式，从派生类内部调用：
class CAnimal;
class CDog inherits CAnimal {};

ECode CDog::Say()
{
  ……
  Super::GetName(&out);  // 调用基类已有实现
  ……
}

第二种形式，从外部调用：
  CDog::New(&pDog);
  IAniaml* pAnimal = IAnimal::Probe(pDog);
  pAnimal->SetName(L”Dog”);  // 通过派生类对象来调用基类已有实现
</pre>
		<h4>2.重载基类的虚接口。</h4>
		  <P>所谓重载基类的虚接口，就是当父类和子类都实现了某个虚接口时，派生类可以用自己的实现重载基类的实现。例如：</P>
<pre class=code>
  IAnimal* pAnimal;
  ISay* pSay = ISay::Probe(pAnimal);
  pSay->Say();  // 调用虚接口的方法
</pre>
      <P>其中ISay是一个虚接口，基类和派生类都有自己的实现。</P>
		<h4>3.接口方法调用具有运行时的多态性</h4>
		  <P>类似于C++的虚方法的多态性，使用ISay*类型的指针调用Say方法，不同的对象具有不同的实现，如果pSay指向CDog，则调用CDog::Say，如果pSay指向的是CCat，则调用CCat::Say。但对于调用代码来说，都是相同的pSay->Say()，不同的构件类实现的ISay具有不同的语义和行为，由此实现了基于构件接口的多态性。</P>
		<h4>4.具有继承关系的构件对象的生命周期。</h4>
		  <P>按照C++的对象构造顺序：先构造继承中的父类，再构造子类。CAR构件的继承机制也具有类似的流程，即当创建某个对象时，会在其初始化函数中判断该类是否具有父类，如果有父类，则会先调用父类的构造函数，再调用子类的构造函数。</P>
		<h3>注意</h3>
		  <P>1.CAR构件类的继承不支持多重继承。</P>
		  <P>2.构件类对象的接口继承采用单继承。</P>
		  <P>3.没有定义虚接口的构件类不能被继承。</P>
		  <P>4.派生类不能继承基类的回调接口，也不能对回调事件进行重载，但其仍可激发基类的回调事件。语法为Super::Callback::xxxx( )(xxxx为回调事件名)。</P>
<pre>





</pre>
	</body>
</html>