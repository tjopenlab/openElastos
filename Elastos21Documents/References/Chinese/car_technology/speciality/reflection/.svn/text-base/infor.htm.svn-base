<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->
<html>
	<head>
		<meta http-equiv=Content-Type content="text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
		<title>reflection infor</title>
	</head>

	<body>
		<h2>CAR反射机制 </h2>
       <p>CAR反射和CAR构件间的关系就像是棱镜和太阳光的关系，棱镜分解太阳光，类似的CAR反射从构件中解析出类、接口和方法等信息，实现信息自动收集。在CAR系统中，构件元数据的解释不依赖于其它的DLL文件，这样就可以通过反射直接从CAR构件里取出元数据。 </p> 
       <p>Java为什么能够支持反射？因为Java运行时仍然拥有类型信息，它包含了这个类的基本信息：它有哪些字段、哪些方法，各是何种保护级别等等，还有这个类依赖于哪些类。在Java中，类信息以对象的形式存放，这些对象是一种元对象，它们的类型就是Class。拥有了这些信息，无论是动态创建对象还是调用某些方法都是轻而易举。在C++中，通过RTTI（运行时类型识别），我们也可以知道类的一些信息，但为什么C++中却没有 反射，原因是类型信息不完整。RTTI这个名字本身就告诉我们，C++的类型信息是用来进行类型识别的，因此，它不需要其它额外的信息。并不是C++无法做到这一点，而是C++不希望给用户增加额外的负担。有所得，必然有所失，因此，C++放弃了元对象。 </p>
       <p>元数据是反射的物质基础。有了元对象，反射也成了一件顺其自然的事情。有了反射，语言也就拥有了动态扩展的能力，这样就可以极大的提高程序的灵活性。 </p>		  
        <p>本节将从以下方面介绍car构件的反射机制：</p>
        <p><li><a class="style1" href= "reflection.htm">Reflection原理 </a></p>
        <p><li><a class="style1" href= "sample.htm">Reflction编程示例 </a></p>

	</body>
		
</html>
