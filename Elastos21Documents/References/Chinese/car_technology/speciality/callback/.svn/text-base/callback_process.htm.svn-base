<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>callback_release</title>
	</head>
	
	<body>
		<h2>回调实现流程</h2>
		  <P>回调机制实现流程如下：</P>
		<h3>1.定义回调接口以及回调事件</h3>
		  <P>在服务器端为构件类定义<B>回调接口</B>，语法为<a href="../../fundamental/development_environment/car/keywords/keywords_callback.htm">callback</a> interface XXX(XXX为回调接口名)，回调接口中的每个成员函数代表一个<B>回调事件</B>。</P>
<pre class=code>
module
{
    interface IBuilding {
        OnFire();
     }  

    interface IFireAlarmRing {
        Employee();
     }

    class CBuilding {
       interface IBuilding;
       callback interface IFireAlarmRing;
    }
}
</pre>		  
		  <P>上例中，在服务器端为构件类CBuilding定义了IFireAlarmRing虚接口，并在虚接口中声明了Employee()回调事件。CBuilding可以在普通接口方法OnFire()中抛出该回调事件。</P>
		<h3>2.激发回调事件</h3>
      <P>在服务器端的普通接口方法中<B>激发回调事件</B>的语法为：Callback::XXX(XXX为回调事件名)。</P>
<pre class=code>
ECode CBuilding::OnFire()
{
    CConsole::WriteLine("The building is on fire!");
    Callback::Employee();
    return NOERROR;
}
</pre>
		<h3>3.实现回调函数</h3>
      <P>在客户端用户需要为所关心的回调事件实现对应的回调函数。如下例：</P>
<pre class=code>
ECode <B>EmployeeRunAway</B>(PVoid,PInterface pSender)
{
    printf("The employee are running away......");
    return NOERROR;
}
</pre>		  
		<h3>4.注册回调函数</h3>
		  <P>在客户端将某个服务器端的回调事件与处理该事件的回调函数一一对应的过程称为回调函数的注册。</P>
		  <P><B>注册回调函数</B>的方法是：在某个线程或者ElastosMain里调用AddXXXCallback。</P>
		  <P>(1)当回调函数为<B>全局函数</B></P>
      <p>参见<a class="style1" href= "API/AddXXXCallback.htm">AddXXXCallback</a></p>
      <P>示例：</P>
<pre class=code>
CBuilding::AddEmployeeCallback(pBuilding,<B>&EmployeeRunAway</B>, NULL);
</pre>
      <P>例中，Employee是回调事件，它指明用户所关心的事件；pBuilding 是构件对象的接口指针，它指明用户所关心的是谁的事件；EmployeeRunAway是回调函数，如果发生用户关心的事件，pBuilding就会调用这个函数。</P>
		  <P>(2)当回调函数为<B>C++类成员函数</B></P>
      <p>参见<a class="style1" href= "API/AddXXXcallback.htm">AddXXXCallback</a></p>		  
      <P>示例：</P>
<pre class=code>
CBuilding::AddEmployeeCallback(pBuilding,&Employee,&CResult::OtherEmployee);
</pre>
      <P>例中，Employee是回调事件，pBuilding是构件对象的接口指针，类CResult的成员函数OtherEmployee是对应的回调函数。</P>
      <P>下例中，用户将其实现的EmployeeRunAway()注册为回调事件Employee的回调函数。</P>
<pre class=code>
ECode ElastosMain(const BufferOf<WString>& args)
{
    ......
    ec = CBuilding::AddEmployeeCallback(pBuilding,EmployeeRunAway, NULL);
    ......
}
</pre>
		<h3>5.响应回调事件</h3>
		  <P>用户程序通过指针调用普通接口方法，随即便触发了定义在该方法中的回调事件，客户端会响应该事件。</P>
<pre class=code>
......
pBuilding->OnFire();
......
</pre>		  
		<h3>6.注销回调事件</h3>
		  <P>在客户端通过RemoveXXXCallback（XXX代表回调事件名）函数来注销曾注册的回调事件。这个函数的参数和AddXXXCallback函数参数一样。</P>
		  <P>(1)当回调函数为<B>全局函数</B></P>
      <p>参见<a class="style1" href= "API/RemoveXXXCallback.htm">RemoveXXXCallback</a></p>
		  <P>(2)当回调函数为<B>C++类成员函数</B></P>
      <p>参见<a class="style1" href= "API/RemoveXXXcallback.htm">RemoveXXXCallback</a></p>
      <P>(3)注销<B>所有的回调事件</B></P>	
      <P>用户可通过RemoveAllCallbacks一次注销所有的回调事件。RemoveAllCallbacks有两个版本，分别对应在服务器端<a class="style1" href= "API/RemoveAllCallbacks.htm">RemoveAllCallbacks</a>和在客户端<a class="style1" href= "API/RemoveAllcallbacks_.htm">RemoveAllCallbacks</a>。</P>	  
<pre>





</pre>
	</body>
</html>