<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>callback_introduce</title>
	</head>
	
	<body>
		<h2>事件回调机制</h2>
		<h3>回调介绍</h3>
		  <p>在CAR构件技术中，回调机制实现了用户程序与构件间的双向函数调用，即不仅用户程序能通过接口调用构件提供的服务，构件也能通过回调接口向外抛出事件，调用用户程序实现的函数。图5-6为回调示意图。</p>
		  <center><img src="images/callback3.JPG"/></center>
		  <center>图5-6</center>
		  <P>回调机制中，抛出回调事件的一方称为<B>服务器端</B>(server)，响应回调事件的一方称为<B>客户端</B>(client)。客户端对于服务器端感兴趣的事件注册回调函数后，当服务器端发生该事件时，其会向与其注册过的客户端广播回调事件通知，客户端在接收到此通知后会执行对应的回调函数。</P>
		  <P>服务器端与客户端之间的关系可以是一对多，也可以是多对一。即一个服务器端可以向多个客户端抛出相同或不同的回调事件；而一个客户端也可接收来自不同服务器端抛出的多个回调事件。图5-7为事件与客户端之间的关系示意图。</P>
		  <center><img src="images/callback2.JPG"/></center>
		  <center>图5-7</center>
		<h3>回调特点</h3>		  
		  <P>CAR的回调具有广播与异步的特征。<B>广播</B>意味著在服务器端抛出的回调事件可被多个客户端响应；<B>异步</B>一方面意味着服务器端在抛出了回调事件后不用等待客户端的回复，而可以继续其它的操作；另一方面，客户端在接受到回调事件通知后不用立刻去执行这个回调事件，而是将其放入自己的<B>消息队列</B>，等待执行。</P>
		<h3>回调解决的问题</h3>
		  <P>CAR事件回调机制适用于并发运行的环境，其预期解决的问题是：当服务器端和客户端之间的依赖关系比较弱，服务器端只想广播一下自己的状态信息，而客户端也只要知道服务器端发生过什么，彼此间的通信没有实时性的要求。</P>
		  <P>例如，如果两个人通过邮政系统通信或者打电话，就不太适合用我们的事件回调机制来实现。邮政信件是两个对象之间的点对点通信，但CAR的回调是可以广播的，可以被N个人注册和接收到，隐私全曝光了。如果是打电话的话，因为回调不具有实时性，对方隔个十分八分再回一句话，肯定郁闷死你。</P>
		  <P>再以进度条更新的应用为例，下载一个文件时要显示下载进度，下载是由一个底层构件实现的，显示是由一个UI程序实现的，一般做法是：底层构件每次收到数据就发个事件给UI，UI计算百分比更新显示。但可能UI处理回调的线程很繁忙，可能底层已经下载了50%但UI才显示了10%，或者由于更新进度条的消息太多，当用户想cancel的时候，这个cancel事件被排在后面，当执行cancel时，已经下载完了等等。</P>
		  <P>面对这种应用，首先要考虑UI设计要求是什么？实时显示真实下载状态？是否要显示整个下载过程？是否能接受进度条不准确或不及时？</P>
		  <P>如果要求实时性，要求进度条绝对反映真实状态，那绝对不应该用CAR的事件回调机制，要想办法直接同步调用。</P>
		  <P>如果可以接受进度条不准确，只是给用户一个心理安慰，那完全可以使用我们的回调机制，并且合并更新进度条的事件避免大量垃圾事件堵塞消息队列，这样用户看到的进度条可能会跳跃着变化，也可能由于下载太快直接就是100%。还可以提高cancel事件的优先级，使其尽快被执行来中止下载。</P>
		  
		<h3>备注</h3>
		<P>1.如果服务器端已停止激发，但客户端仍被回调，可能是消息队列中还有未被处理的消息。</P>
		<P>2.如果服务器端激发了事件，但客户端没被回调，可能是消息处理线程还未启动或者已结束</P>
		<P>3.调用回调函数时pSender无效进入debug，可能是对象对象已被释放（nRef==0）。</P>
		<P>4.客户端被回调时不要假设服务器端当前的状态，因为两者可能处于两个线程；同样，服务器端也不该假设事件抛出后客户端会如何反应，因为客户端的线程可能根本没被CPU调度。</P>
		<P>5.如果服务器端文档描述某个方法会触发回调，要说明这个触发是同步触发还是异步触发</P>
		<P>6.由callback关键字定义的回调接口，其声明的回调事件的参数属性必须为[in]； </P>
		<P>7.由callback关键字定义的回调接口不能继承其它接口，也不能被其它接口继承。</P>
		<P>8.构件类中至少应定义一个普通接口，不能只包含回调接口，,否则编译出错。</P>
		<P>9.如果服务器端在一个独立进程，客户端在其它不同进程，那么每个进程都有一个接收器对象(sink)来与服务器端进行通信，每个接收器对象负责本进程内针对服务器端的回调事件处理。</P>
	</body>
</html>