<html>
	<head>
		<meta http-equiv=Content-Type content = "text/html; charset=GB2312">
		<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
    <script src="/xsl/docstyles.js"></script>
    <title>callback_background</title>
	</head>
	
	<body>
		<h2>引入背景</h2>
		  <P>普通函数调用是指应用程序调用由系统或其它程序实现的函数，而回调恰好相反，是指应用程序自己实现某些函数，用于被系统DLL或其它程序调用。这种函数称为回调函数，其一般用于截获消息、获取系统信息或处理异步事件。</P>
		  <P>通常，如果某个处理流程具有确定性，而流程中某个具体的处理环节需要根据实际情况具体处理，就可以将这个流程固定下来，在需要具体处理的地方“安插”适当的回调函数接口。通过以下两个示例可以说明回调的应用。</P>
		  <P><B>示例1：</B></P>
		  <P>当同一进程中的两个线程之间通信时，线程A会通过一个标志来告诉线程B某个事件发生了，或者某个状态改变了，在线程B里会有一个while循环，每过一段时间就去检查那个标志，反复的探查标志是否变化。</P>
<pre class=code>
Extern int g_nFlag;
Void ThreadRoutine(…)
{
……
While（g_nFlag） {
    Sleep(100);
}
…… // do something…}
</pre>
      <P>此处“反复检查标志”可视为一个固定的流程，而“标志发生变化”则为流程中需具体处理的一个回调事件。线程A向线程B注册这个事件后，线程A可以继续其它工作，不需要傻等在那里，因为当回调事件发生时，B会自动回调A的某个函数。</P>
		  <P><B>示例2：</B></P>
		  <P>在用户UI操作过程中，有时候要等待某个点击事件发生，然后执行相应的处理代码；有时要等待用户输入，再做相应处理。常用的实现方法是把发生的事件放在一个队列里，然后起一个线程处理所有的事件。</P>
	
		  <P>以上这个实现方法需要用户自己创建线程，处理队列事件等，较为麻烦。如果利用回调机制，只要把点击事件的处理代码放在回调函数里，然后将这个回调函数注册给UI，则当发生点击事件时UI会回调这个函数，就不用再重复地去写循环、处理事件以及队列了。见图5-4</P>
		  <center><img src="images/callback1.JPG"/></center>
		  <center>图5-4</center>

<pre>
	
	
	
	
</pre>
	</body>
</html>