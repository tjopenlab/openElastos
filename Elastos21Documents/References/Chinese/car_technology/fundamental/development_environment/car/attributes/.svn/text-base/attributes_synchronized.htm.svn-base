<!--==========================================================================-->
<!-- Copyright (c) 2000-2009,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=GB2312">
<link rel="stylesheet" href="/xsl/docdemo.css" type="text/css">
<script src="/xsl/docstyles.js"></script>
<title>CAR关键字--synchronized </title>
</head>

<body>
	<h2>synchronized</h2>
	    <b>含义 </b>
	        <p> 此属性标识构件对象同时只允许一个线程进入到构件的实现代码中，其它访问该构件对象的线程将被阻塞等待。</p>
	
	    <b>语法 </b>
<pre class = code>
 [<b>synchronized</b>]
 class className classBody;
</pre>
	    <b>使用说明 </b>
	        <p>1.synchronized属性和<a class="style1" href= "attributes_sequenced.htm">sequenced属性</a>不能同时使用。 </p>
	        <p>2.使用synchronized属性或<a class="style1" href= "attributes_sequenced.htm">sequenced属性</a>，构件对象都是通过加锁来保证方法调用的互斥，但使用synchronized属性时，当线程调用该构件实例的任一方法时，将首先自动获取该实例相关联的锁对象；当调用方法返回之后，才会自动释放相关联的锁对象。 </p>
	        <p>3.泛用synchronized容易造成死锁，但利于严谨的同步查错。 </p>
	        <p>4.<a class="style1" href= "attributes_sequenced.htm">sequenced属性</a>和synchronized属性不能修饰<a class="style1" href= "../keywords/keywords_applet.htm">applet类</a>。</p>
	    <b>使用范例 </b>
	        <p>例如foo.car： </p>
<pre class= code>
module
{
    interface IFoo{
        Foo1();
        Foo2();
    }

    [<b>synchronized</b>]
        class CFoo {
        interface IFoo;
    }
}

</pre>
	        <p>上面的foo.car构件编译生成后的cpp文件，修改如下：(其中黑体部分是编译器自动生成的代码框架) </p>
<pre class= code>
<b>#include "CFoo.h"
#include "_CFoo.cpp"</b>

#define Sleep(ms) CThread::Sleep(ms, NULL)

<b>ECode CFoo::Foo1()
{</b>
    CConsole::WriteLine("Enter CFoo::Foo1()");
    Sleep(20);
    CConsole::WriteLine("Leave CFoo::Foo1()");
    return NOERROR;
<b>}</b>

<b>ECode CFoo::Foo2()
{</b>
    CConsole::WriteLine("Enter CFoo::Foo2()");
    Sleep(20);
    CConsole::WriteLine("Leave CFoo::Foo2()");
    return NOERROR;
<b>}</b>

</pre>
	        <p>Synchronized会为每个方法加了锁。与<a class="style1" href= "attributes_sequenced.htm">sequenced</a>的区别在于，Sychronized会对Foo1()函数整体加锁。 </p>
	        <p>例如，执行上述Foo1()方法的伪代码如下： </p>
<pre class= code>
CFoo::Foo1()
{
    EnterCriticalSection(&_m_CFooLock);
    CConsole::WriteLine("Enter CFoo::Foo1()");
    Sleep(20);
    CConsole::WriteLine("Leave CFoo::Foo1()");
    return NOERROR;

    LeaveCriticalSection(&_m_CFooLock);
}

</pre>
	        <p>编写客户端代码如下： </p>
<pre class= code>
#include "foo.h"
using namespace Elastos;

//线程函数
ELFUNC Thread1(void *pArg)
{
    IFoo *pIFoo = (IFoo *)pArg;
    for (int n = 0; n < 2; n++) {
        pIFoo->Foo1();
    }
    return NOERROR;
}

int main()
{
    ECode ec;
    IFoo* pIFoo;
    IThread *pThread;
    int n;

    //创建一个构件对象
    ec = CFoo::New(&pIFoo);
    if (FAILED(ec)) return ec;

    //创建一个线程
    ec = CThread::New(Thread1, pIFoo, 0, &pThread);
    if (FAILED(ec)) {
        pIFoo->Release();
        return ec;
    }

    for (n = 0; n < 2; n++) {
        pIFoo->Foo2();
    }
    pThread->Join(INFINITE, NULL);
    pThread->Release();
    pIFoo->Release();
    return NOERROR;
}

</pre>
	        <p>运行后的结果为： </p>
<pre class= code>
Enter CFoo::Foo2()
Leave CFoo::Foo2()
Enter CFoo::Foo1()
Leave CFoo::Foo1()
Enter CFoo::Foo2()
Leave CFoo::Foo2()
Enter CFoo::Foo1()
Leave CFoo::Foo1()
</pre>
	        <p>上述客户端代码中，主线程两次调用接口方法Foo2()，并新开一新线程，该新线程两次调用接口方法Foo1()。从运行结果可以看出，Foo1()与Foo2()并发执行，但Foo2()方法执行完才执行Foo1()，同样Foo1()方法执行完Foo2()才能再次执行。 </p>

        <b><a class="style1" href="../attribute.htm">【CAR属性关键字列表】</a></b>
<script>footer("chinese")</script>

</body>

</html>