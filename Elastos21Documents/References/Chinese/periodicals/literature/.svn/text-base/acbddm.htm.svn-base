<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>杜永文:构件化驱动程序模型</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>

<body>
    <p>《计算机工程与应用》2003年第39卷第5期, 2003年2月</p>
   
    <h2><center>构件化驱动程序模型</center></h2>
    <center>杜永文，何华灿</center>
    <center>(西北工业大学计算机科学与工程系，710072)</center>
    <center>陈榕</center>
    <center>(北京科泰世纪科技有限公司，100084)</center>
    
    <h4>摘  要:</h4>
        <p>本文首先分析了传统的UNIX操作系统驱动程序模型，指出其存在的局限性；其次介绍了构件技术，并将构件技术运用到设备驱动程序设计中，提出了构件化驱动程序模型，并试图弥补UNIX系统的驱动程序模型存在的问题；最后还通过构造基于新模型的鼠标驱动程序展示了新的驱动程序模型。</p>
    
    <h4>关键字:</h4>
        <p>构件技术，设备驱动模型，组件对象模型</p>
    
    <h2><center>A COMPONENT-BASED DEVICE DRIVER MODEL</center></h2>
        
    <h4>Abstract</h4>
        <p>In this paper, we analysis the traditional device driver model in UNIX operating system and point out pitfalls existing in this model. Then we propose component-based device driver model, that make it possible to clearly descript and easily access device. Finally, a mouse driver will be presented to exhibit component-based device driver model.</p>
    
    <h4>Keywords</h4>
        <p>component technique, device driver model, component object model</p>
    
    
    <h3>1. 引言</h3>
        <p>硬件设备是操作系统管理的重要资源，而设备驱动程序则是使用软件方法访问和操作硬件设备的重要环节，因此驱动程序以及相关的模块就成为系统程序的必要组成部分。</p>
        <p>设备驱动程序作为系统程序的一部分，实际上它是一组数据结构和函数，这些数据结构和函数通过精心定义的接口，控制一个或多个设备，并与系统的其它部分交互。</p>
        <p>在UNIX系统中设备驱动是内核的一部分，实际上，设备驱动程序是否处于内核中，这并非是设备驱动程序的本质特征，许多操作系统可以把设备驱动程序置于核外，作为提供设备服务的服务器。就这点来说，我们考虑的实际上是设备驱动程序模型的问题。</p>
        <p>驱动程序模型着眼于以下因素：a. 设备驱动程序的管理；b. 驱动程序在整个系统框架中的位置；c. 用户与驱动程序的交互。驱动程序本身都受限于这些因素，在这些因素确定后，再考虑设备的具体细节，相应的设备驱动程序就成型了。从因素b可以看出，驱动程序模型是系统框架的一部分，讨论驱动程序模型自然要涉及系统框架。本文第二部分将讨论UNIX操作系统的驱动程序模型。</p>
        <p>随着嵌入式应用的广泛普及和设备的多样化，对于设备驱动程序的研究显得更为重要。模块化、便于升级、稳定性已经成为设备驱动程序必不可少的特性，为了适应新的需求，有必要改造驱动程序模型，建立新的驱动程序模型。</p>
        <p>纵观以往操作系统中驱动程序的模型，尤其类似UNIX系统中设备驱动程序，往往是同文件系统相关联的，用户通过系统提供的统一接口访问硬件设备，这样系统和驱动程序耦合过于紧密，导致驱动程序用户接口不够灵活，这点将在第二部分着重论述。</p> 
        <p>第三部分主要介绍构件技术的发展以及现况；第四部分考虑用构件技术重新来构造驱动程序，提出构件化的驱动程序模型，弥补了UINX驱动程序模型的一些缺陷；最后用新的模型构造鼠标驱动，展示了构件化驱动程序模型。</p>
    
    <h3>2. UNIX操作系统的驱动程序模型[1]</h3>
        <center><img src="images/acbddm_fig1.bmp"></center>
        <center>图一: UNIX设备驱动程序作用</center>
        <p>这整个过程分为几层来实现，每一层有明确定义的环境和职责。用户应用程序不必知道它是在访问设备驱动程序还是普通文件。一个将数据写到文件中的程序就应该能够在不作修改的情况下将同样的数据写到一个终端或串行线上。用户对于驱动程序的访问是通过系统调用陷入到内核中，内核将所有设备操作传递给I/O子系统，由它来负责所有独立于设备的处理。I/O子系统并不关心某个特定设备的特性，它将设备看作设备驱动程序接口处理的高层抽象，其关心的只是访问权限、数据缓冲和设备命名等。</p>
        <p>UNIX系统中的驱动模型和I/O子系统的的设计实际上是提供了一个一致的、高级的文件视图，所有设备的处理都是文件处理的方式。内核可以对所有设备类(UNIX中的设备分为块设备类、字符设备类和网络设备类等，它们的设备驱动程序接口有所不同)一视同仁，通过相同的接口访问设备。驱动程序模型和操作系统之间有事实上的标准和规范，通过它们可完成驱动程序和应用程序之间的数据交换和信息传递。</p>
        <p>这些标准和规范是一个统一的驱动程序接口，实际上就是下面的两个设备开关表：</p>
        <pre class="code">
bdevsw {
    int(* d_open ) ();
    int(* d_close) ();
    int(* d_strategy) ();
    int(* d_size) ();
    int(* d_xhalt) ();
    ......    
} bdevsw[]:


        </pre>
        <center>表一: 设备开关表</center>
        <pre class="code">
cdevsw {
    int(* d_open)();
    int(* d_close)();
    int(* d_read)();
    int(* d_write)();
    int(* d_ioctl)();
    int(* d_mmap)();
    int(* d_segmap)();
    int(* d_xpoll)();
    int(* d_xhalt)();
    struct streamtab* d_str;
    .....
} cdevsw[]

        </pre>
        <center>表二: 字符设备开关表</center>
        <p>每个驱动程序提供了设备开关表的特定于某个设备的实现。从发展上看，UNIX的驱动程序模型具有一定的先进性，正如[1]中所说，"从面向对象的角度来说，驱动程序接口是抽象的基类，每个驱动程序是一个子类，或者是基类的特殊实现"，但是它也存在一定的缺陷和局限性。</p>
        <p>驱动程序的统一接口抹杀了硬件设备的多样性，打印机和鼠标是两种截然不同的硬件，具有不同的物理特性，在UNIX中它们却同属于字符设备，都要实现字符设备开关表中的功能，单从接口角度很难理解同一种方法在这两种不同设备上会产生什么效果，换言之，根本不可能从接口原型获取设备操作的丝毫概念，要使用具有这样接口的驱动程序就必须仔细阅读驱动程序的用户指南。</p>
        <p>统一的驱动程序接口还带来了另一个弊端，驱动程序的客户端程序或多或少要了解设备内部的一些细节。如访问鼠标驱动程序，读操作d_read从它的数据缓冲参数向用户返回鼠标事件信息，数据缓冲参数如何表示鼠标事件？各种信息（左右键状态和坐标值变化）在数据缓冲中的摆放位置明显涉及了设备内部的细节。另外，端口控制操作d_ioctl更能说明这一点，它把端口操作直接交由用户来控制，设备在用户面前暴露无遗，其后果造成用户程序、驱动程序和硬件设备之间的紧耦合，不利于用户程序的移植。</p>
        
    <h3>3. 构件技术[2]</h3>
        <p>近几年来，以面向对象为基础发展起来的软件构件技术，虽然在理论上还未完善，但从某种层面上说，它克服了以往的面向对象技术的某些缺陷。</p>
        <p>面向对象是将系统划分为多个对象（数据和相关方法的结合体），通过对象之间的通信和互操作形成耦合系统，它提供了客观世界与软件系统进行对应的编程思维方式，其具体技术包括：(1)封装性；(2)多态性；(3)继承性。</p>
        <p>应该严格地说构件技术仍然是面向对象技术，只不过它较之早期的面向对象技术着眼点有所不同。</p>
        <p>早期的面向对象技术主要考虑在单一的小系统内如何使用面向对象的语言或面相对象的编程范式来构建对象，将对象与外部无关的特性和操作封装起来，使用对象的共用属性和共用方法实现对象之间的互操作，这种模式只能从源程序层面上实现代码的复用，软件的升级则是使用编链好的新软件整个替代旧软件，静态链接技术可以实现一定层次的代码复用，但并没有带来本质的变化。动态模块插入技术，如DLL技术部分有效地解决了软件复用问题，它使得由小的软件模块在运行期动态组合构成复杂软件成为可能。为了解决组合在一起的小模块之间的交互和互操作问题，产生了构件技术。</p>
        <p>用软件构件技术来诠释面向对象技术，软件系统可拆分成相对独立的构件，构件之间通过约定的接口进行数据交换和信息传递，构件的位置是相互透明的，而且不同的构件可以使用不同的语言编写，只要它们符合事先约定的构件规范。图二展示了构件技术编程模型。</p>
        <center><img src="images/acbddm_fig2.bmp"></center>
        <center>图二: 构件技术编程模型</center>
        <p>经过多年来的发展，构件本身的模型及其规范已经提出，较有影响的有微软的COM和ORG的CORBA。 COM是微软对于软件发展的一个重大贡献，它是基于接口的构件技术，正如前面所分析的，COM扩展了传统的面向对象编程技术。</p>
        
    <h3>4. 构件化驱动程序设计</h3>
        <p>构件技术已经广泛应用于应用软件的开发过程中，在系统软件设计中运用构件技术已经成为研究的热点，特别是分布式系统的发展，为构件技术提供了广阔的施展空间。</p>
        <p>将构件技术运用到驱动程序设计中的尝试还是相当鲜见的，但的确有人已经这么做过。Steve Maillet在[3]中提出了在嵌入式系统上运用 COM技术封装设备驱动程序，他所涉及的内容也仅止于此，并没有从系统管理的层面来讨论 COM技术封装设备驱动程序的意义及实现的方法，换言之，他并没有从系统级支持构件化驱动程序技术，仅从实现层面进行简单包装。这样就限制了构件技术优势的发挥，包括互操作性，生命周期管理，跨地址空间，跨机器操作等优势都将消失殆尽。因为它只涉及到进程内部处理，并不涉及进程间构件对象的使用问题，要做到这一点就需要操作系统在系统层面支持，否则将无从谈起。文[4]中提出了基于实时嵌入式系统的一种驱动程序模型，在该模型中，驱动程序作为系统模块由单独的线程控制，应用程序和驱动程序之间的数据和信息交换不是通过驱动程序接口完成，而是直接使用数据共享的IPC机制，后面会看到这有别于本文提出的模型，在本文的模型中，用户程序是通过驱动程序的接口访问和操作驱动程序。</p>
        <p>构件化驱动程序模型可从几个方面进行刻画：</p>
        <p>(1) 用COM技术封装驱动程序，驱动程序提供系统和用户两类接口，驱动程序同外部交互必须通过这些接口完成；</p>
        <p>(2) 系统提供驱动程序管理模块，负责控制驱动程序构件对象的生命周期，硬件资源管理；</p>
        <p>(3) 以独立的目标模块承载驱动程序构件，这样的目标模块可以动态加载。</p>
        <center><img src="images/acbddm_fig3.bmp"></center>
        <center>图三:  构件化设备驱动程序</center>
        <p>构件化驱动程序模型已经在Elastos 操作系统平台上实现，并且使用了ezCOM 构件技术封装驱动程序，由于本文并不阐明构件化驱动程序模型实现细节，而是只讨论理论框架，因此不讨论Elastos操作系统和ezCOM技术。图3粗略地显示了构件化驱动程序模型在系统中的布局。</p>
        <p>将构件技术引入到驱动程序的设计和实现中，为驱动程序带来了许多好的特性，下面从多个方面来说明构件化驱动程序模型的改进。</p>
        <p>构件化驱动程序模型能够充分地利用构件技术的高度模块化特征。构件化驱动程序由独立的目标模块承载就体现了这一点，更重要的是驱动程序与外部的交互完全通过接口进行，保证了驱动程序实现细节不会影响驱动程序的使用程序，必要时系统可以根据需要动态地置换和升级驱动程序。</p>
        <p>构件技术介入到驱动程序模型的改造过程中，也使得 I/O子系统更加容易管理。设备驱动构件对象周期管理就使用了类似于COM对象的管理技术，可以说大部分成熟的构件管理技术经过一定修改都可以运用到驱动程序构件的管理中。当然不同于普通的构件对象，驱动构件对象是绑定在特定的硬件设备上，这涉及到如何给驱动构件对象分配硬件资源，如中断号、DMA频道、端口范围和与设备相连的内存，系统的驱动程序管理模块会负责这些工作。</p>
        <p>另外，从aspect  programming的角度来说，构件化驱动程序模型更符合这种理念。一个硬件设备对于用户和系统来说是不同的，这里所谓的不同是由于观察的角度不同和关注的焦点不同造成的。</p>
        <p>如一株观赏性植物在普通欣赏者的角度来看，它的整体或与周围的环境一起构成了能够形成视觉美感的自然图画，这是从视觉感官来看待这株植物；而在园艺工人的眼中，它不光是园林构图的一部分，他们更关心的是如何摆放，如何修剪这株植物。</p>
        <p>类似的，一个硬件设备所占用的资源是系统所关注的，获取释放和使用硬件资源都应在系统监控下进行，换言之，系统应对这些行为加以管理。而硬件设备传递的信息一般系统并不关心（UNIX系统的操作方式是设备的信息由系统截获并通过相关途径传递给用户，虽然系统并不关心这些信息的内容，但由于系统和信息传递机制耦合过于紧密，这些信息的包装形式、传递形式等确实受到了系统的限制），只有硬件设备的使用者才希望获取和处理这些信息。所以对系统和用户程序来说，硬件设备是不同的，从逻辑描述角度看，它们是看到了一个对象的不同侧面，如果用构件技术描述，它反映为同一构件对象的不同接口，具体就设备描述而言，就是这个驱动程序构件应该具有两种类型的接口，其中一类是用于系统管理设备驱动程序对象，另一类是用于用户程序访问硬件设备。用这两类接口描述驱动程序能够清晰地描述硬件功能，访问硬件设备也变得更容易。</p>
        <p>从深层看，造成构件化驱动程序模型和UNIX驱动程序模型的本质不同的原因是：构件化驱动程序模型把驱动程序看作一个服务程序，它和用户程序通过系统提供的中间层（即图二中的代理构件）进行信息传递，中间层在信息传递过程中遵从的规范并不涉及用户程序和服务程序的逻辑实现，也不限制用户程序和服务程序之间通信接口的形式（和逻辑相关的）和语义，这就保证了服务程序的独立性和模块化的特征。这就是构件化驱动程序模型根本的转变，它从根本上降低了驱动程序与系统的其它部分的耦合程度。</p>
        <p>在构件化驱动程序模型中，系统提供的中间层是根据系统在运行期获取的接口信息动态生成的，因此即使驱动程序的接口形式发生变化，也不会影响用户程序和驱动程序的正常交互。这种模式还能够保证用户访问分布式系统上的远程设备。</p>
        
    <h3>5. 构造构件化鼠标驱动程序</h3>
        <p>本节将通过构造鼠标驱动程序框架来展示构件化驱动程序模型，由于微软的COM技术是比较熟知的一种构件技术，因此我们采用COM的表达形式来构造鼠标驱动程序，编程语言使用了C++语言。</p>
        <p>表五中的代码描述了CMouse类，它就是鼠标驱动构件的描述，它具有两个接口，表三中的IMouse接口中包括了鼠标使用者（用户程序或者上层系统程序，如windows的GDI系统）访问鼠标设备的各种方法，如设置鼠标硬件的参数和获取鼠标事件，表四中的IDevice是系统对象和系统资源管理者使用的接口，通过该接口系统可以管理鼠标驱动对象，使之绑定在硬件设备上，并赋予其特定地一些资源，如中断请求号等，当然也可以得到设备驱动的一些系统级特性。</p>
        <pre class="code">
// IMouse接口的唯一标识符
GUID IID_IMouse;
    // 设备的用户接口，便于用户操作设备
interface IMouse : IUnknown
{
        ECODE WaitForEvent(
                [out] MouseEvent* event);

        ECODE GetResolution(
                [out] long* Resolution);

        ECODE SetResolution(
                [in] long newResolution);

        ECODE GetSyncType(
                [out] long* SyncType);

        ECODE SetSyncType(
                [in] long newSyncType);
}


        </pre>
        <center>表三: 鼠标用户接口IMouse描述</center>
        <pre class="code">
// 设备的系统接口
interface IDevice : IUnknown
{
        ECODE init(DeviceInfo DevInfo);

        ECODE start();

        ECODE shutdown();

        ECODE uninit();

        ECODE GetDeviceState(…);

        ECODE RegisterDriver(…);
        ......
}

        </pre>
        <center>表四: 鼠标系统接口IDevice描述</center>
        <pre class="code">
// CMouse构件的唯一标识符
GUID CLSID_CMouse;
    // 驱动程序构件的声明
class CMouse : public IMouse, IDevice
{
public:
    void *operator new(size_t size);
public:
// IMouse, IDevice接口的方法及
// 私有成员变量
……
};

// CMouse重载的new操作
void * CMouse::operator new(size_t size)

    IMouse* pIMouse;
    ECODE ec;
    ec  = CoCreateObject(
                      CLSID_CMouse,
                      NULL,
                      CLSCTX_KERN_PROCESS,
                      IID_IMouse,
                      &pIMouse);
    if(FAILED(ec)) return NULL;
    return pIMouse;
}
        </pre>
        <center>表五:  鼠标构件驱动声明</center>
        <p>下面是客户端使用CMouse鼠标驱动构件的代码，其中第一句就是创建一个CMouse构件对象，如果创建成功，我们就可以通过返回的IMouse接口操作和访问鼠标硬件了。</p>
        
        <pre class="code">
// 在内核中创建鼠标驱动组件的一个实例
IMouse iMouse = new CMouse;

// 如果创建对象成功，完成相应动作
if(iMouse != NULL) {
    iMouse.SetResolution(...);
    iMouse.WaitForEvent(event);
    if( event == LEFTBUTTONDOWN )
        {...}
}
 ...
        </pre>
        <center>表六: 鼠标驱动客户端代码</center>
        <p>这里构造的范例主要是从逻辑层面上说明构件化驱动程序模型，其中给出的接口设计不一定完全合理。IDevice接口和IMouse接口有一个非常重要的不同之处 ，IDevice是系统驱动管理模块使用的接口，它应满足一定的原型；IMouse则不同，只要用户和驱动程序达成共识即可。</p>
        
    <h3>6. 总结</h3>    
        <p>本文将构件化技术运用于驱动程序研究，提出了不同于传统的UNIX驱动程序模型的构件化驱动程序模型，它降低了驱动程序和系统其它部分之间的耦合程度，能够更清晰地描述硬件设备，使驱动程序更便于使用。</p>
        <p>本文仅从理论框架描述构件化驱动程序模型，对一些重要的细节并未阐述，其中包括系统的构件技术框架，以及驱动程序管理模块中涉及到的硬件管理技术。</p>
        
    <h3><center>参考文献</center></h3>
        <p>1. U. Vahalia, UNIX Internals: The New Frontiers, Prentice-Hall, 1996.</p>
        <p>2. 陈榕, 中间件技术在嵌入式操作系统中的应用, Proc. of Workshop on Embedded System, Oct 2001.</p>
        <p>3. Steve Maillet, Using COM for Embedded Systems (Part II), Embedded System Conference Session #425, 2000.</p>
        <p>4. Moy, M. and D. Stewart, "An engineering approach to determining sampling rates for switches and sensors in real-time systems," Proc. of Real-Time Applications Symposium, Washington DC, May 2000.</p>
        <p>5. D. Stewart, "Software components for real time," Embedded Systems Programming, Dec 2000, pp.100-138</p>
    
<script>footer("chinese")</script>
</body>
</html>