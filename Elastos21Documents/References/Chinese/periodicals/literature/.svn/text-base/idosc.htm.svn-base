<!--==========================================================================-->
<!-- Copyright (c) 2000-2006,  Elastos, Inc.  All Rights Reserved.-->
<!--==========================================================================-->

<html>
<head>
<title>因特网时代的操作系统演变</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<script src="/xsl/docstyles.js"></script>
</head>

<body>
   
    <p>《计算机世界》2001年10月29日B17版"YOCSEF-CCW专家视点"专刊文章</p>
    <h2><center>因特网时代的操作系统演变</center></h2>
    <center>北京科泰世纪科技有限公司首席科学家 陈榕</center>

    <p>操作系统存在的目的只有一个，就是为了更好地支持应用程序运行。在某种程度上，操作系统所提供的支持决定了应用程序的工作方式。随着因特网时代的到来，应用程序模型已经发生了很大变化。这些变化对操作系统提出了新的要求，也必将引起操作系统的新发展。本文将简要介绍现代操作系统如何演变和它在未来编程实践中的重要作用。</p>    
    
    <h3>1. 传统操作系统及视窗操作系统</h3>
        <p>因特网时代以前的传统应用软件，大多是静态链接而成，由某一家公司提供，所有功能都集成在同一个软件中，一旦链接之后就不可能替换其中的软件模块。那时的操作系统有两大功能：首先它向用户提供一个分时系统；其次是向用户提供一组函数库。用户程序从主程序起，一步一步驱动软件控制流程，最终完成计算工作。操作系统始终处于被动地位，为用户程序提供服务。这类系统的典型范例有DOS和控制台模式下的Unix操作系统，以及目前存在的大多数嵌入式操作系统。</p>
        <p>基于图形界面的视窗应用软件为了更好地响应键盘，鼠标等外部事件，采用了不同的模式。应用程序从主程序起，一项一项声明所需菜单、选项、窗口等用户界面，注册用户事件（event）的反应函数（callback function），然后应用软件控制流程进入称为消息泵（message pump）的一个死循环，相当于把用户程序控制流交给操作系统。当用户事件发生时操作系统再来调用用户注册的反应函数。就是说操作系统的地位是先被动后主动。这类系统一般叫作基于消息机制的操作系统，比如微软的Windows和Unix上的X-Window。</p>
        <p>写过视窗程序的人都知道视窗软件的这个消息泵都是千篇一律的，操作系统如果为用户程序"提取公因式"，这段代码理应变成操作系统的一部分。但是这一项编程进化所带来的好处不足以值得改变已有的操作系统模型，因此程序员只好"千古文章一大抄"，将这段死循环抄到所有视窗程序里。其实抄也罢了，只是多写几行程序，浪费一点内存，但是这种消息泵机制还有许多弊病。多数外部事件从硬件驱动程序开始，经过成千上万行代码，被操作系统一直送到那个消息泵死循环里，最后因为用户程序对那些事件根本不感兴趣而不了了之。最典型的是鼠标的移动事件，大多数都是白白浪费CPU时间。光浪费时间也罢了，反正现在硬件速度日新月异。但是由于用户可以自定义事件，视窗对象的反应函数就可能要处理无限多种消息，成为一个没有边界的，开放的模型，因此视窗不可能是真正意义上的"面向对象"。</p>
        <p>面向对象技术除了需要定义一个数据结构，还需要定义一组作用于这一数据结构的运算，比如C++语言的虚函数表（v-table），其中函数表的项数只能是有限多个。所以，视窗对象模型的理论基础薄弱，缺乏编程语言的有力支持，其历史局限性日益明显。以视窗对象模型为基础的"面向对象"软件包的典型代表有微软的MFC（Microsoft Foundation Classes）。MFC对象永远也不可能"即插即用"（ready to use）。用户程序需要继承并扩展MFC对象，其中关键的步骤是要通过"消息图"（message map）来定义向某一视窗对象发送的消息。在给定的应用领域（application domain）里用户程序只向某一视窗对象发送有限多种消息，也就是只做有限多种运算。可是在MFC 体系中，定义运算个数的工作是通过特殊的宏定义，在源程序的预处理时才能确定。换句话说，MFC对象总是半生不熟，必须在用户程序员加工后才可以使用，因此编程模型非常复杂，不能适应软件工厂化的需求。</p>
        
    <h3>2. 因特网时代应用模型的演变</h3>
        <p>下面举一个因特网时代应用程序的例子，它包括了文字、图表、音频、连续图像播放等功能，见图一。其中各部分功能的软件模块可以来自不同的软件开发商，它们都是即插即用，在运行时动态组织起来，向用户提供了一个"天衣无缝"的具有复合功能应用软件。也许读者会说这种应用看上去象因特网的浏览器。这话只说对了一半，其实这种组件化（componentization）的软件工程技术早在因特网时代之前就已经初见端倪，比如微软的OLE技术在90年代初就可以初步支持Word和Excel应用相互嵌套。不同的是，在因特网时代的今天，组件化技术可以说是无处不在。比如微软最近发表的Windows XP和Office XP的核心都是采用这种组件技术，从视窗桌面到Word和Excel的窗口全部是"浏览器"，其主要特点是：</p>
        <p>(1) 程序作为动态组件自动加载运行，而不需要由用户去逐个启动。</p>
        <p>(2) 组件支持脚本语言控制，多个组件可以相互操作，交换信息。</p>
        <p>(3) 以浏览器为交互式操作界面，既便于有户掌握，又为程序开发提供了统一标准。</p>
        <center><img src="images/idosc_fig1.bmp"></center>
        <center>图一: 因特网应用举例：来自不同软件开发商的软件模块动态组织起来运行</center>
        <p>在这种新的因特网应用模式下，"浏览器"实际上已经退化为一个可见或不可见的"框"。用操作系统术语讲，这个框是一个可执行文件，或说是一个EXE文件；它本身非常简单，不能为用户提供任何应用功能。但是它能为其它组件提供运行环境，而由其它组件提供应用功能。所有组件都被做成一个个动态链接库，或说是DLL文件。因为这个小"框"放之四海而皆准，对于任何应用程序都是一样的，操作系统自然可以代劳，在操作系统中做一份就行了。在这种操作系统里启动运行这样一个小小的可执行文件，通常根本不用访问外部存储器（如磁盘），所以效率很高。框里的第一个组件一般需要有一个主函数（main），但是含有主函数的组件并不一定要是第一个加载的组件。这种组件中的主函数与传统操作系统术语中用户程序里的主函数有本质上的区别。熟悉JAVA的读者可能会联想到，这里讲的操作系统模型就是JAVA虚拟机的编程模型。</p>
        <p>既然应用程序员只写组件或动态链接库，而操作系统自始至终控制程序运行的主动权，显而易见，这种操作系统与DOS或Unix有本质的不同。操作系统可以对应用程序组件进行各种各样的控制，使得封装好的组件能够适应不同的运行环境和用户要求。组件制造商对组件运行环境往往有些特殊的复杂要求，例如组件是否支持多线程或信息加密，这些对于一般用户来讲很难理解和适应；而众多用户的不同好恶，如怀疑组件有病毒，也不是组件制造商料所能及的。这时操作系统控制主动权，动态生成中间件和构造组件运行环境，就能很好地解决这些问题。操作系统利用中间件技术支持和控制应用程序的运行环境，就形成了因特网时代操作系统的关键技术。关于更详细的中间件技术，读者可以参见作者的《浅谈因特网时代编程与中间件技术》一文，这里不另赘述。</p>

    <h3>3. 硬件设备即插即用</h3>
        <p>Unix操作系统将文件系统与硬件设备模型统一起来，大大减少了设备驱动函数的数量，降低了人们理解硬件设备的难度。Unix通过一张规定的函数表来访问文件和被抽象化的外设，具体函数包括：open，close，read，write，ioctl等。可以说Unix文件模型是最早的面向对象模型的成功应用范例之一。在没有办法取得关于具体硬件的任何信息的情况下，操作系统可以通过读写文件的"副作用"（side-effect）来控制硬件设备，比如：打开某个特殊名字的文件，实际上是建立对鼠标的访问。但是这种方法并没有彻底解决问题。所有对于鼠标的访问都以对文件读写的形式进行，这样就难免有问题。读取某厂家的鼠标"文件"中第100字节等于读取鼠标的X坐标；另一厂家的鼠标"文件"中第100字节可能是Y坐标。第三家的鼠标还增加了一个滚动轮。这些问题在原来的模型中是无法解决的。</p>
        <p>毕竟近30年过去了，人们对于对象、组件、中间件的理解已经是今非昔比。因特网时代要求硬件设备能即插即用，光靠"副作用"不可能区分打印机与光盘机。解决方案只能是在驱动程序对象中加入非执行的描述信息，这种描述信息就是通常所说的元数据（metadata）,它可以"告诉"访问者它有哪些特性和功能。元数据可以是XML形式、二进制或两者兼有。我们知道对象加上元数据就是组件。操作系统可以根据组件中的元数据生成中间件。这种在内核里动态生成的中间件是连接驱动组件与用户程序的"桥梁"，而这"桥梁"是内核根据硬件设备的元数据动态生成的，此时的新型操作系统仍然是"以不变应万变"。例如，一架VCD机的元数据显示它可以有4种动作，分别用"放送"、"停止"、"快进"、"快退"表示。操作系统和浏览器可以将这四个词组画在屏幕上，而根本不需要懂得它们的含义。当终端用户点击"放送"时，这一动作信息通过"桥梁"送到驱动组件，VCD机竟然动起来了！这并不是因为操作系统"支持"某种型号的VCD机，而是因为操作系统和VCD机都遵循组件化的硬件驱动模式。假想另一架VCD机支持5种动作，操作系统和播放软件（浏览器）是否可以不做修改照样工作呢？</p>

    <h3>4. 体系结构由固定变为灵活</h3>
        <p>迄今为止，操作系统体系结构大致分为两种：大内核（Monolithic Kernel）和微内核（Micro Kernel）。传统的大内核操作系统将图形、设备驱动、文件系统等全部功能在操作系统内核中实现，运行在内核状态、同一地址空间。优点是减少进程间通信和状态切换的系统开销，获得较好的运行效率。缺点是内核庞大，占用资源多，剪裁不易，并且一旦个别驱动程序运行出错，就会导致整个系统崩溃，稳定性、安全性不好。与此相反，微内核在内核中只实现那些必须由内核实现的基本功能，而将图形、文件系统、设备驱动、通讯等功能放在内核之外，作为系统服务来提供相应的功能，这些程序在用户状态下运行。这样做的优点是有一个精炼的内核，便于剪裁、移植。由于系统服务程序运行在用户地址空间，个别驱动程序的错误不至于导致整个系统崩溃。缺点是在运行中用户状态和内核状态要频繁切换，这样会导致系统效率的降低。</p>
        <p>由于组件、中间件技术，可以做到组件运行环境对用户和组件制造者透明，例如组件可以不加修改运行于不同地址空间。在未来的组件化操作系统中，可以把操作系统的内核地址区看成是一段特殊的地址空间，根据用户的需要，将一些来源值得信赖或对运行效率要求高的驱动程序配置于内核态，而另一些不太稳定的驱动程序置于用户态，在一个系统中同时满足稳定性、安全性与实时性的特殊要求。在这样的体系结构中，我们不必区分是大内核还是微内核，事实上所谓的"内核"可大可小，完全依据系统自身的需求动态决定。我们称这种操作系统体系结构为"灵活内核"（Agile Kernel）。北京科泰世纪公司首先独创性地提出了"灵活内核"结构，并已经在使用组件和中间件技术来解决长期以来困扰操作系统体系结构设计者的大内核和微内核在性能、效率两者之间不能两全其美的矛盾，见图二。</p>
        <center><img src="images/idosc_fig2.bmp"></center>
        <center>图二: 灵活内核技术</center>
        
    <h3>5. 浏览器成为统一的用户界面</h3>
        <p>在网络应用时代，浏览器已经不仅仅是一个显示网络页面信息的界面，除了显示图形和文字以外，它还需要包含其它功能，诸如解释网络页面的信息，与底层的系统软件协同完成处理这些信息的工作。在这个过程中，经常还需要调动其他资源。浏览器与组件技术的结合，特别是对组件中元数据的直接解释执行，通常被称为"浏览器引擎"(browser engine)。浏览器引擎将会成为强有力的工具，可以很方便地实现丰富多彩的用户界面，完成通常由传统桌面系统的应用程序所完成的功能。例如解释网络页面的内容或启动应用程序组件，将其在任何平台或设备上展示给用户；支持业界广泛使用的网络标准，支持通用的页面描述语言、脚本语言、资源描述语言等；通过用户接口语言可以开发跨平台、跨设备的用户接口；通过跨平台的组件、中间件对象模型，实现可扩展的图形体系结构。比如支持同一用户图形软件完成远程图形功能（类似X-Window）或在同一进程内的高速图形显示。同一段用户图形组件代码可以不经修改，运行在硬件上或台式机的网页里，见图三。</p>
        <center><img src="images/idosc_fig3.bmp"></center>
        <center>图三: 同一个二进制PDA组件代码可以运行于PDA硬件或台式机的网页里</center>
    
    <h3>6.操作系统对XML的支持</h3>
        <p>XML文本描述语言的广泛使用将是因特网时代操作系统的另一明显标志。从表面上看XML是比网页描述语言HTML更广义的一种新型信息交换描述语言。可仔细分析起来，XML的每个标签（tag）都可以由用户定义，标签成对出现，这种文法与40多年前的LISP语言几乎如出一辙。我们不难看出，XML实际上是一种面向函数（functional oriented）的可执行语言。和二进制文件以及一般文本文件相比，XML兼顾了对于人的可读性和计算机的处理效率。从组件技术对于数据格式的要求来看，XML统一了对网络上传输的数据和远程函数调用的描述，比如IBM公司积极推动的SOAP（Simple Object Access Protocol）。如果说HTML 描述的是"怎样显示"信息， XML描述的可以说是"这是什么"信息，至于怎样显示是另外一回事。XML对任意消息中的信息都要进行描述，我们称这类消息为自描述消息。由于自描述消息可以根据不同国家语言，不同操作系统，不同软件版本，或不同安全协议来作不同解释。</p>
        <p>XML已经成了因特网信息交换的标准，未来的操作系统内核会对XML进行最有效的支持。现在网络和分布式操作系统中有大量的守护进程（daemon process），比如HTTPD、FTPD、TELNETD等服务器，它们都运行于用户态，处于等待状态。当客户端程序到特定的TCP/IP 端口来访问时，相应的服务器就启动（fork）一个进程去处理。这样多的二进制协议端口对外开放，在安全上是一些隐患。在内核对XML远程函数调用功能的支持之下，这些服务器都可以统一用一个HTTPD 服务器来取代。所有的请求都以XML格式发送给HTTPD，根据请求的种类，由HTTPD创建一个相应的服务器进程去处理。表面上看，操作系统对XML的处理速度可能不如处理二进制协议高，但内核避免了不必要的地址空间切换，大幅度减少众多守护进程的内存消耗，因而势必增加系统的安全性、可靠性以及运行效率。微软的Microsoft.Net就是按照这一思路去设计操作系统。</p>
        <p>我们可以将网络时代应用重点的转移以及操作系统技术的发展归纳为图四。</p>
        <center><img src="images/idosc_fig4.bmp"></center>
        <center>图四: 因特网时代操作系统技术的发展</center>
        <p>基于因特网技术的应用发展趋势是：桌面应用正在向网络应用转移，从网上获得的不仅是一般信息，还包括程序、交互式应用。新的网络应用环境带来了新的运算模型：应用程序由多厂家产品组合而成；跨平台、跨设备的网络应用模式；浏览器成为实现这种组合并且能够相互操作的框架、平台，同时又是一个提供相同的用户体验、智能互动、统一的操作界面。</p>
        <p>随着组件技术日趋完善，人们也逐步认识到组件技术的巨大潜力。工厂化软件生产的条件和技术已经日臻成熟。为适应新时代要求，操作系统的概念正在经历一系列"沧海桑田"的重大变化，下一代操作系统呼之欲出。这些变化将给计算机软件带来前所未有的发展空间，其中所蕴含的巨大商机正在吸引着各大软件公司，他们纷纷根据自己的特长，提出因应之道，微软的 .net 和Sun 的Java是其中最显眼的两家。 在这新一轮突破性发展的初期阶段，势单力薄的中国软件能否利用这个机会挤进跑道呢？让我们共同努力。</p>


<script>footer("chinese")</script>
</body>
</html>